# Inheritance
Inheritance is the mechanism that allows one class (called the **child** or **derived class**) to acquire the properties (fields) and behaviors (methods) of another class (called the **parent** or **base class**), enabling code reuse and establishing a hierarchical relationship between classes. Inheritance is a fundamental concept in object-oriented programming (OOP) that promotes the **"is-a"** relationship between classes, allowing derived classes to extend or modify the functionality of base classes. 
> If class `Car` inherits from class `Vehicle`, we can say: "A Car is a Vehicle."

## 🎯 Goals of Inheritance
- **Code Reusability**: 
  - Allows derived classes to reuse code from base classes, reducing duplication and improving maintainability.
  - **Example**: `Vehicle` defines `Start()` and `Stop()`.  
  `Car`, `Truck`, `Bike` all inherit and reuse these methods without rewriting.

- **Extensibility**:
    - Add **new functionality** to a derived class without changing the base class.
    - Supports **open/closed principle** (Open for extension, closed for modification).
    - **Example**: You can add `TurboBoost()` to `SportsCar` without altering the base class `Vehicle`.
  
- **Maintainability**:
    - If shared behavior changes, update it **once** in the base class and it reflects in all derived classes.
    - Reduces maintenance effort and chance of inconsistency.

- **Polymorphism**:
    - Treat different derived classes as instances of the same base type, enabling **dynamic method dispatch**.
    - **Example**: Even though the list is of type `Vehicle`, it works for all subclasses.
    ```cs
    List<Vehicle> vehicles = new List<Vehicle> { new Car(), new Truck() };
    foreach (var v in vehicles) v.Start();
    ```
- **Logical Hierarchy & Clarity**:
    - Organizes code into **natural “is-a” relationships**.
    - Improves readability and helps model real-world entities in a structured way.
    - **Example**:
    ```
    Animal
        ↳ Mammal
            ↳ Dog
            ↳ Cat
        ↳ Bird
            ↳ Sparrow
    ```


## ✅ Ways C# supports inheritance:

### 1. Class Inheritance
C# supports single inheritance for classes, where a derived class can inherit from one base class using the `:` syntax:
```cs
public class Animal { }
public class Dog : Animal { }
```

### 2. Interface Implementation
Classes can implement multiple interfaces, providing a form of multiple inheritance for contracts:
```cs
public class Animal { }
public interface IMovable { }
public interface ISpeakable { }
public class Dog : Animal, IMovable, ISpeakable { }
```

### 3. Virtual and Override Keywords
Base classes can define virtual methods that derived classes can override:
```cs
public class Animal
{
    public virtual void MakeSound() { }
}
public class Dog : Animal
{
    public override void MakeSound() { Console.WriteLine("Bark"); }
}
```

### 4. Abstract Classes and Methods
Abstract classes cannot be instantiated directly and can contain abstract methods that must be implemented by derived classes:
```cs
public abstract class Shape
{
    public abstract double CalculateArea();
}

public class Circle : Shape
{
    private double radius;
    public Circle(double radius) { this.radius = radius; }
    public override double CalculateArea() => Math.PI * radius * radius;
}
```

### 5. Access Modifiers
C# provides `protected` access modifier specifically for inheritance, allowing members to be accessible to derived classes but not to external code.

### 6. Base Keyword
The `base` keyword allows derived classes to access members of the base class, including constructors, methods, and properties:
```cs
public class Dog : Animal
{
    public override void MakeSound()
    {
        base.MakeSound(); // Call base implementation
        Console.WriteLine("Bark");
    }
}
```

### 7. Sealed Classes and Methods
C# allows you to prevent further inheritance by marking a class as `sealed` or a method as `sealed` in a derived class:
```cs
public sealed class FinalClass
{
    public void Display() { Console.WriteLine("Final Class"); }
}

public class BaseClass
{
    public virtual void Display() { Console.WriteLine("Base Class"); }
}

public class DerivedClass : BaseClass
{
    public sealed override void Display() { Console.WriteLine("Derived Class"); }
    // note: only override methods can be marked as sealed
}
```

## Interview Questions

### Q. What is the syntax for inheritance in C#?
In C#, inheritance is implemented using the `:` syntax. A derived class inherits from a base class by specifying the base class name after the colon. Here’s the basic syntax:

```cs
public class BaseClass { }
public class DerivedClass : BaseClass { }
```

**Key points about C# inheritance:**
- **Single inheritance**: A class can only inherit from one base class directly
- Multiple inheritance can be achieved using interfaces.
- **Access modifiers**: Derived classes inherit all `public`, `protected`, and `internal` members from the base class, but not `private` members
- **Constructor chaining**: Use `base()` to call base class constructors
- **Method overriding**: Use `virtual` in base class and `override` in derived class

---

### Q. Can a class inherit from multiple classes in C#? Why or why not?
No, a class cannot inherit from multiple classes in C#. C# supports **single inheritance** for classes, meaning a derived class can only have one direct base class. This design choice avoids the complexities and ambiguities associated with multiple inheritance, such as the **diamond problem**, where a derived class inherits from two classes that both inherit from a common base class.
Instead, C# provides a way to achieve similar functionality through the use of **interfaces**. A class can implement multiple interfaces, allowing it to inherit and fulfill multiple contracts while maintaining clear and unambiguous class hierarchies.  
- **Multiple Interface Implementation:**: A class can implement multiple interfaces
    ```cs
    public class MyClass : BaseClass, IInterface1, IInterface2, IInterface3  // ✓ Valid
    {
        // Must implement all interface members
    }
    ```
- **Interface Inheritance Chain:**: Interfaces themselves can inherit from multiple interfaces
    ```cs
    public interface IInterface1 { }
    public interface IInterface2 { }
    public interface ICombinedInterface : IInterface1, IInterface2 { }  // ✓ Valid
    ```

---

### Q. What is the difference between public, protected, and private inheritance in C#?
In C#, the terms **public inheritance**, **protected inheritance**, and **private inheritance** as they appear in some other languages like C++ do not exist as distinct forms of inheritance. Instead, C# uses access modifiers **public**, **protected**, and **private** primarily to control member accessibility, not inheritance itself. Here's how these modifiers relate to inheritance and member access in C#:

- **public**: Members declared `public` are accessible from any other code in any assembly. When a base class member is public, it is accessible through the derived class instance anywhere.
- **protected**: Members declared `protected` are accessible within the declaring class and by derived classes. This is the key modifier that enables a derived class to access base class members that are not public but still intended for subclasses.
- **private**: Members declared `private` are accessible only within the declaring class itself, and they are not accessible in derived classes. Such members are not inherited in an accessible form.  

**Access Modifier Summary**:
| Modifier | Accessible From |
| --- | --- |
| `public` | Everywhere |
| `protected` | Same class + derived classes |
| `internal` | Same assembly |
| `protected internal` | Same assembly OR derived classes |
| `private protected` | Same assembly AND derived classes |
| `private` | Same class only |

**Example**:
```cs
public class BaseClass
{
    public int PublicField;        // Accessible everywhere
    protected int ProtectedField;  // Accessible in derived classes
    private int PrivateField;      // Only accessible within this class
    internal int InternalField;    // Accessible within same assembly
}

public class DerivedClass : BaseClass
{
    public void TestAccess()
    {
        PublicField = 1;      // ✓ Accessible
        ProtectedField = 2;   // ✓ Accessible (inherited)
        InternalField = 3;    // ✓ Accessible (same assembly)
        // PrivateField = 4;  // ✗ Not accessible
    }
}
```

---

### Q. What is the difference between inheritance and composition?
**Inheritance ("is-a" relationship)**  
Inheritance creates a parent-child relationship where the derived class extends or specializes the base class.
- Represents an "is-a" relationship (a Car is a Vehicle)
- Derived class inherits all public and protected members from the base class
- Supports polymorphism - you can treat derived objects as base class objects
- Creates a tight coupling between classes
- Established at compile time and cannot be changed at runtime
```csharp
public class Vehicle
{
    public void Start() { /* implementation */ }
    public void Stop() { /* implementation */ }
}

public class Car : Vehicle  // Car IS-A Vehicle
{
    public void OpenTrunk() { /* implementation */ }
}
```

**Composition ("has-a" relationship)**  
Composition involves building classes by including instances of other classes as members.
- Represents a "has-a" relationship (a Car has an Engine)
- The containing class uses functionality from contained objects
- Creates loose coupling between classes
- More flexible - can change behavior at runtime by swapping composed objects
- Follows the principle "favor composition over inheritance"
```csharp
public class Engine
{
    public void Start() { /* implementation */ }
    public void Stop() { /* implementation */ }
}

public class Car
{
    private Engine engine;  // Car HAS-AN Engine
    
    public Car()
    {
        engine = new Engine();
    }
    
    public void Start()
    {
        engine.Start();  // Delegates to composed object
    }
}
```

**Use Inheritance when:**  
- There's a clear "is-a" relationship
- You need polymorphism
- The relationship is stable and unlikely to change
- You want to share common interface/behavior across related classes

**Use Composition when:**
- There's a "has-a" relationship
- You need flexibility to change behavior at runtime
- You want to avoid deep inheritance hierarchies
- You need to combine functionality from multiple sources
- You want looser coupling between components

---

### Q. What is the difference between `virtual`, `override`, and `new` keywords?
The `virtual`, ` override`, and `new` keywords in C# are used to control polymorphism and the way methods, properties, or indexers behave in class hierarchies. Here's how they differ:
| Keyword  | Used In      | Purpose                                                        | Behavior                                                                 |
|----------|--------------|----------------------------------------------------------------|--------------------------------------------------------------------------|
| virtual  | Base class   | Declares that a method/property/indexer can be overridden in a derived class | Enables a derived class to provide its own implementation using override. |
| override | Derived class| Indicates that a method/property/indexer overrides a virtual/abstract member in base | Provides a new implementation that replaces the base class’s virtual/abstract implementation. |
| new      | Derived class| Hides a member of the base class (not override)               | Defines a new member with the same name, hiding the base member—this is not overriding and is not polymorphic. |

**`virtual`:**
- Declared in the base class to let derived classes override the method/property/indexer.
- Invoking a virtual member on a base reference will call the most derived override at runtime.
- Example:
    ```csharp
    public class BaseClass {
        public virtual void Display() {
            Console.WriteLine("BaseClass Display");
        }
    }
    ```

**`override`:**
- Used in the derived class to provide a new implementation for a virtual or abstract member from the base class.
- Method signature must match the base class's virtual method.
- Example:
    ```csharp
    public class DerivedClass : BaseClass {
        public override void Display() {
            Console.WriteLine("DerivedClass Display");
        }
    }
    ```

**`new`:**
- Used when you want to hide a member inherited from the base class, *not* override it.
- The base class version and the derived class version are treated as entirely separate.
- Hide any member (including non-virtual ones), but this does not participate in polymorphism.
- Example:
    ```csharp
    public class DerivedClass : BaseClass {
        public new void Display() {
            Console.WriteLine("DerivedClass Display (New)");
        }
    }
    ```

**Polymorphism Comparison:**
- `override` enables true polymorphism—calling through a base reference uses the derived override.
- `new` only hides the base implementation—calling through a base reference uses the base version; calling through a derived reference uses the new version.
- Example:
    ```csharp
    BaseClass obj = new DerivedClass();
    obj.Display();

    // override: invokes DerivedClass.Display()
    // new: invokes BaseClass.Display()
    ```

---

### Q. Can constructors be inherited in C#? If not, how are base constructors called?
In C#, constructors are **not inherited** by derived classes. This means that when a class derives from a base class, it does not automatically gain the constructors of the base class. Constructors are not considered class members and, therefore, are not inherited in the same way that methods or properties are. 

**How Base Constructors Are Called**  
When you create a derived class constructor, you can explicitly call a base class constructor using the `base` keyword:
```csharp
public class Animal
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    // Base class constructor
    public Animal(string name, int age)
    {
        Name = name;
        Age = age;
    }
}

public class Dog : Animal
{
    public string Breed { get; set; }
    
    // Derived class constructor calling base constructor
    public Dog(string name, int age, string breed) : base(name, age)
    {
        Breed = breed;
    }
}
```

**Default Constructor Behavior**  
If you don't explicitly call a base constructor, C# automatically calls the parameterless constructor of the base class. This can cause compilation errors if the base class doesn't have a parameterless constructor:
```csharp
public class Animal
{
    public Animal(string name) { } // Only parameterized constructor
}

public class Dog : Animal
{
    // This will cause a compiler error because Animal has no parameterless constructor
    public Dog() 
    {
    }
    
    // This works - explicitly calls the base constructor
    public Dog(string name) : base(name)
    {
    }
}
```

**Constructor Chaining**  
You can also chain constructors within the same class using `this`:
```csharp
public class Dog : Animal
{
    public string Breed { get; set; }
    
    public Dog(string name) : this(name, 0, "Unknown")
    {
    }
    
    public Dog(string name, int age, string breed) : base(name, age)
    {
        Breed = breed;
    }
}
```
The key point is that while constructors aren't inherited, the base class constructor logic still runs when creating derived class instances - you just need to explicitly specify which base constructor to call if there isn't a parameterless one available.

---

### Q. What is method hiding in C# and how does it differ from overriding?
Method hiding in C# is a mechanism that allows a derived class to define a new method with the same signature as a method in its base class, effectively "hiding" the base class method. This is accomplished using the `new` keyword.  

**Method Hiding (`new` keyword):**  
- Creates a completely new method that shadows the base class method
- The method called depends on the compile-time type of the variable
- No polymorphic behavior - each class has its own independent method
- The base class method is still accessible through casting or base class references

**Method Overriding (`override` keyword):**  
- Replaces the base class method implementation
- Requires the base method to be marked as `virtual`, `abstract`, or `override`
- Exhibits polymorphic behavior - the actual runtime type determines which method is called
- The base class method is completely replaced in the inheritance hierarchy

**Example:**
```csharp
// Base class
public class Animal
{
    public virtual void MakeSound() => Console.WriteLine("Animal makes a sound");
    public virtual void Move() => Console.WriteLine("Animal moves");
}

// Method Overriding
public class Dog : Animal
{
    public override void MakeSound() => Console.WriteLine("Dog barks");
}

// Method Hiding
public class Cat : Animal
{
    public new void Move() => Console.WriteLine("Cat prowls silently");
}

// Usage
Animal animal1 = new Dog();
Animal animal2 = new Cat();

animal1.MakeSound(); // Output: "Dog barks" (polymorphic - override)
animal2.Move();      // Output: "Animal moves" (non-polymorphic - hiding)

Cat cat = new Cat();
cat.Move();          // Output: "Cat prowls silently" (direct call to hidden method)
```

**Key Differences:**  
- **Polymorphism:** Overriding maintains polymorphic behavior, while hiding breaks it
- **Virtual method table:** Overriding updates the vtable entry, hiding creates a separate entry
- **Accessibility:** Hidden methods can still be accessed through base class references
- **Design intent:** Overriding is for "is-a" relationships, hiding is for "replaces functionality"

Method hiding is generally discouraged unless you specifically need to break polymorphic behavior, as it can lead to confusing code where the method called depends on how the object is referenced rather than its actual type.

---

### Q. What is the purpose of the `base` keyword in inheritance?  
The `base` keyword in inheritance serves to access members (methods, properties, constructors, etc.) from the parent class within a derived class. Its primary purposes are:  

**1. Calling Parent Class Constructors**  
```csharp
public class Animal
{
    public string Name { get; set; }
    
    public Animal(string name)
    {
        Name = name;
    }
}

public class Dog : Animal
{
    public string Breed { get; set; }
    
    public Dog(string name, string breed) : base(name)  // Calls Animal constructor
    {
        Breed = breed;
    }
}
```

**2. Accessing Overridden Methods**  
```csharp
public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("Some generic animal sound");
    }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        base.MakeSound();  // Call parent's version first
        Console.WriteLine("Woof!");
    }
}
```

**3. Accessing Hidden Members**
```csharp
public class Parent
{
    public void Display()
    {
        Console.WriteLine("Parent display");
    }
}

public class Child : Parent
{
    public new void Display()
    {
        base.Display();  // Access parent's hidden method
        Console.WriteLine("Child display");
    }
}
```

**Key Benefits:**  
- **Code reuse**: Extend parent functionality rather than completely replacing it
- **Proper initialization**: Ensure parent class constructors are called appropriately
- **Maintainability**: Changes to parent class behavior automatically propagate to derived classes when using `base`
- **Avoiding duplication**: No need to rewrite parent class logic in derived classes  

In summary, the **base keyword** is essential in inheritance for explicitly referencing the base class's implementation, ensuring correct object initialization, and enabling you to build upon or integrate with underlying logic from parent classes.

---

### Q. What happens if a derived class does not call the base class constructor?
When a **derived class does not explicitly call a base class constructor** in C#, outcomes depend on whether the base class has a parameterless (default) constructor:

- **If the base class has a default constructor:**
  The compiler automatically inserts a call to `base()` at the start of the derived class constructor. The base part of the object gets initialized using the base’s default constructor before any code in the derived constructor runs. This ensures the base class is always properly initialized.

- **If the base class does not have a default constructor:**
  The compiler cannot insert a default call to `base()`. In this situation, if the derived class does not explicitly call a base constructor (with required arguments) using : `base(args)`, a compile-time error occurs. You must use the `base` keyword in the constructor initializer of the derived class to call an available base constructor with appropriate parameters.

> **Constructor Execution Order:**  
> The base class constructor is always executed *before* the derived class constructor body runs, ensuring the base part of the object is set up first.

---

### Q. What is the difference between interface inheritance and class inheritance in C#?
In C#, interface inheritance and class inheritance are two different mechanisms for establishing relationships between types, each serving distinct purposes:  

**Class Inheritance**  
Class inheritance creates an "is-a" relationship where a derived class inherits implementation from a base class.
- **Single inheritance**: A class can only inherit from one base class
- **Implementation inheritance**: The derived class inherits both the interface (method signatures) and implementation (method bodies) from the base class
- **Access to base members**: Derived classes can access protected and public members of the base class
- **Method overriding**: Virtual methods can be overridden in derived classes
- **Constructor chaining**: Base class constructors are called during derived class instantiation
```csharp
public class Animal {
    public virtual void MakeSound() { Console.WriteLine("Some sound"); }
    protected string name;
}

// Class inheritance 
public class Dog : Animal { 
    public override void MakeSound() { Console.WriteLine("Woof!"); }
}
```

**Interface Inheritance**   
Interface inheritance establishes a contract that implementing classes must fulfill. 
- **Multiple inheritance**: A class can implement multiple interfaces 
- **Contract inheritance**: Interfaces define what methods/properties must exist, but not how they're implemented
- **Polymorphism**: Different classes can implement the same interface in different ways
- **Loose coupling**: Promotes flexible, testable code design
```csharp
public interface IFlyable { void Fly(); }

public interface ISwimmable { void Swim(); }

// Class + interface inheritance
public class Duck : Animal, IFlyable, ISwimmable {
    public void Fly() { Console.WriteLine("Flying with wings"); }
    public void Swim() { Console.WriteLine("Swimming with webbed feet"); }
}
```
> Interface inheritance is particularly valuable for dependency injection, unit testing, and creating flexible architectures where you want to depend on abstractions rather than concrete implementations.

---

### Q. What are abstract classes, and how do they relate to inheritance?
Abstract classes in C# are classes that cannot be instantiated directly but serve as base classes for other classes. They're designed to provide a common structure and shared functionality that derived classes can inherit and build upon.
- **Cannot be instantiated**: You cannot create objects directly from an abstract class using `new`. They exist solely to be inherited by other classes.
- **Can contain both abstract and concrete members**: Abstract classes can have regular methods with implementations alongside abstract methods that must be implemented by derived classes.
- **Use the `abstract` keyword**: Both the class and any abstract methods within it must be marked with the `abstract` modifier.

Abstract classes are fundamentally tied to inheritance - they establish an "is-a" relationship between the base abstract class and its derived classes. Here's how they work together:
- **Enforced Implementation**: When a class inherits from an abstract class, it must implement all abstract methods. This ensures that derived classes follow a specific contract while allowing flexibility in how they implement the required functionality.
- **Shared Code Reuse**: Abstract classes can contain concrete methods and properties that all derived classes inherit, reducing code duplication.
- **Polymorphism Support**: You can use abstract class references to point to objects of any derived class, enabling polymorphic behavior.

**Example**
```csharp
// Abstract base class
public abstract class Animal
{
    // Concrete property - inherited by all derived classes
    public string Name { get; set; }
    
    // Concrete method - inherited by all derived classes
    public void Sleep()
    {
        Console.WriteLine($"{Name} is sleeping");
    }
    
    // Abstract method - must be implemented by derived classes
    public abstract void MakeSound();
    
    // Abstract method - must be implemented by derived classes
    public abstract void Move();
}

// Derived class - must implement all abstract methods
public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine($"{Name} barks: Woof!");
    }
    
    public override void Move()
    {
        Console.WriteLine($"{Name} runs on four legs");
    }
}

public class Bird : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine($"{Name} chirps: Tweet!");
    }
    
    public override void Move()
    {
        Console.WriteLine($"{Name} flies through the air");
    }
}
```

**Usage Example**
```csharp
// Cannot do this - compilation error
// Animal animal = new Animal(); // Error!

// Can do this - polymorphism in action
Animal[] animals = {
    new Dog { Name = "Buddy" },
    new Bird { Name = "Tweety" }
};

foreach (Animal animal in animals)
{
    animal.Sleep();     // Calls inherited method
    animal.MakeSound(); // Calls overridden method
    animal.Move();      // Calls overridden method
}
```

**Abstract Classes vs Interfaces**  
While both establish contracts for derived types, abstract classes differ from interfaces because they can provide actual implementation code that derived classes inherit. Interfaces (prior to C# 8.0) could only define method signatures, while abstract classes can contain both abstract methods and concrete implementations.  
Abstract classes are particularly useful when you have a group of related classes that share common functionality but need to implement certain behaviors differently.

---

### Q. What is the difference between sealed methods and sealed classes?  
**Sealed methods** and **Sealed classes** are both mechanisms used to control inheritance, but they apply to different aspects of class design (scope) and have distinct purposes.  
**Sealed Classes**  
- A **sealed class** is a class that cannot be inherited by any other class.
- This restriction ensures that no one can derive new classes from a sealed class; attempting to do so results in a compile-time error.
- Sealed classes are useful for preventing further inheritance, securing class hierarchies, and sometimes for enabling certain optimizations by the compiler or runtime.
```csharp
// Sealed class example
public sealed class Singleton
{
    private static readonly Singleton instance = new Singleton();

    // Private constructor prevents instantiation from outside
    private Singleton() { }

    public static Singleton Instance => instance;
}
```

**Sealed Methods**
- A **sealed method** is a method in a derived class that overrides a virtual method from a base class and then prevents further overriding by any additional derived classes.
- Only an overridden method can be marked as sealed, and it must combine the `sealed` and `override` keywords.
- This prevents further subclasses from changing (overriding) the method’s behavior, while still allowing the inheriting class to provide its own final implementation.
```csharp
public class BaseClass
{
    public virtual void Display()
    {
        Console.WriteLine("BaseClass Display");
    }
}

public class DerivedClass : BaseClass
{
    public sealed override void Display()
    {
        Console.WriteLine("DerivedClass Display");
    }
}

public class FurtherDerivedClass : DerivedClass
{
    // This would cause a compile-time error
    // public override void Display()
    // {
    //     Console.WriteLine("FurtherDerivedClass Display");
    // }
}
```
---

### Q. What is the diamond problem in inheritance, and why doesn’t C# have it with classes?
The diamond problem is a classic inheritance ambiguity that occurs in object-oriented programming when a class inherits from two classes that both inherit from the same base class, creating a diamond-shaped inheritance hierarchy.  
Consider this scenario:  
```
    A
   / \
  B   C
   \ /
    D
```
If class D inherits from both B and C, and both B and C inherit from A, then D has two paths to reach A's members.  
This creates ambiguity: if A has a method `foo()` that both B and C override differently, which version should D inherit?  
Languages like C++ allow multiple inheritance and thus face this problem. When D tries to access a method from A, the compiler doesn't know whether to use the version that came through B or through C.  

**Why C# Doesn't Have This Problem**
C# does not support multiple inheritance for classes, which eliminates the diamond problem. In C#, a classes only support single inheritance. This means that there is a single path to the base class's members, avoiding the ambiguity present in multiple inheritance scenarios.  

**C# and Interfaces**
While C# classes don't support multiple inheritance, they do support implementing multiple interfaces. However, this doesn't create the diamond problem because:  
- **Interfaces don't contain implementation** (traditionally - though C# 8.0+ allows default interface methods)
- **No state/fields** - interfaces only define contracts
- **Explicit interface implementation** - allowing a class to define how it fulfills the contract of an interface without causing ambiguity with other interfaces or base classes

```csharp
interface IFlyable { void Fly(); }
interface ISwimmable { void Fly(); } // Same method name

class Duck : IFlyable, ISwimmable{
    public void Fly() => Console.WriteLine("Flying in air");
    
    // Explicit implementation for disambiguation
    void ISwimmable.Fly() => Console.WriteLine("Flying underwater");
}
```
Even with C# 8.0's default interface methods, the language provides mechanisms to resolve ambiguities explicitly, preventing the diamond problem from occurring.

---

### Q. How is diamond problem resolved when interfaces are inherited from a common interface?  
When multiple interfaces are inherited from a common interface—forming a diamond-shaped hierarchy in C#—**the diamond problem is avoided because interfaces do not provide implementation or state**; they only define method signatures.

**Diamond Inheritance with Interfaces**
```csharp
interface IShape { void Draw(); }

interface IColorable : IShape { void SetColor(string color); }

interface IResizable : IShape { void Resize(double factor); }

// Diamond structure - inherits from both IColorable and IResizable
interface IAdvancedShape : IColorable, IResizable { void Animate(); }
```

**Why This Doesn't Cause Problems**  
1. **Interface Flattening**  
   C# flattens the interface hierarchy. When a class implements `IAdvancedShape`, it must implement ALL methods from the entire hierarchy:
   ```csharp
   class Rectangle : IAdvancedShape
    {
        public void Draw() => Console.WriteLine("Drawing rectangle");
        public void SetColor(string color) => Console.WriteLine($"Setting color to {color}");
        public void Resize(double factor) => Console.WriteLine($"Resizing by {factor}");
        public void Animate() => Console.WriteLine("Animating rectangle");
    }
    ```
    There's no ambiguity because there's only **one implementation of `Draw()`** in the class, even though it satisfies the contract for all interfaces that require it. Even though `Draw()` appears multiple times in the inheritance chain, the implementing class provides exactly one implementation that satisfies all the interfaces:
    ```csharp
    Rectangle rect = new Rectangle();
    IShape shape = rect;
    IColorable colorable = rect;
    IResizable resizable = rect;

    // All of these call the same Draw() method
    shape.Draw();
    colorable.Draw();  
    resizable.Draw();
    ```

2. **No State Duplication**  
    Traditional interfaces don't have fields or state, so there's no question of which "copy" of inherited state to use.

3. **Single Method Implementation**  
    Even though `Draw()` appears multiple times in the inheritance chain, the implementing class provides exactly one implementation that satisfies all the interfaces:
    ```csharp
    Rectangle rect = new Rectangle();
    IShape shape = rect;
    IColorable colorable = rect;
    IResizable resizable = rect;

    // All of these call the same Draw() method
    shape.Draw();
    colorable.Draw();  
    resizable.Draw();
    ```

**Default Interface Methods (C# 8.0+)**  
With default interface methods, you can have implementations in interfaces, which could theoretically create diamond problems:
```csharp
interface IShape { 
    void Draw() => Console.WriteLine("Default shape drawing"); 
}

interface IColorable : IShape {
    void IShape.Draw() => Console.WriteLine("Colorable shape drawing");
}

interface IResizable : IShape {
    void IShape.Draw() => Console.WriteLine("Resizable shape drawing");  
}

interface IAdvancedShape : IColorable, IResizable { }

class Shape : IAdvancedShape {
    /*
    Compiler error: Interface member 'IShape.Draw()' does not have a most specific implementation. 
    Neither 'IColorable.IShape.Draw()', nor 'IResizable.IShape.Draw()' are most specific. 
    */
}
```

**Resolution Strategies**  
C# provides several ways to resolve ambiguities:

1. **Explicit Resolution in the Interface**
    ```csharp
    interface IAdvancedShape : IColorable, IResizable {
        // Explicitly choose which implementation to use
        void IShape.Draw() => Console.WriteLine("Advanced shape drawing");
    }
    ```

2. **Class-Level Resolution**
    ```csharp
    class Rectangle : IAdvancedShape {
        // Class implementation takes precedence over interface defaults
        public void Draw() => Console.WriteLine("Rectangle drawing");
    }
    ```

3. **Most Specific Interface Wins**  
    If there's a clear "most derived" path, C# will choose that implementation automatically.


**Key Differences from Class Diamond Problem**  
- **Single Implementation**: Classes provide one implementation that satisfies multiple interface contracts
- **No State Inheritance**: No duplicate fields or properties to worry about
- **Explicit Resolution**: Language provides clear mechanisms to resolve any ambiguities
- **Compile-Time Checking**: Ambiguities are caught at compile time, not runtime  

The diamond problem with interfaces is fundamentally different because interfaces define contracts, not implementations, and C# ensures there's always a clear, unambiguous way to fulfill those contracts.

---

### Q. How does C# resolve method calls when multiple interfaces have the same method signature?  
In C#, when a class implements multiple interfaces that have methods with the same signature, the resolution depends on how the methods are implemented and how they're called.  

**Implicit Interface Implementation**  
When you implement interfaces implicitly, all interfaces with the same method signature share a single implementation:
```csharp
interface IDrawable { void Draw(); }

interface IPrintable { void Draw(); }

class Document : IDrawable, IPrintable {
    public void Draw() {
        Console.WriteLine("Drawing document");
    }
}

// Usage - same method called regardless of interface reference
Document doc = new Document();
IDrawable drawable = doc;
IPrintable printable = doc;

doc.Draw();        // "Drawing document"
drawable.Draw();   // "Drawing document"  
printable.Draw();  // "Drawing document"
```

**Explicit Interface Implementation**  
To provide different behavior for each interface, you use explicit interface implementation:  
```csharp
class Document : IDrawable, IPrintable {
    void IDrawable.Draw() {
        Console.WriteLine("Drawing on screen");
    }
    
    void IPrintable.Draw() {
        Console.WriteLine("Drawing on paper");
    }
}

// Usage - method called depends on interface reference
Document doc = new Document();
IDrawable drawable = doc;
IPrintable printable = doc;

// doc.Draw();        // Compiler error - no public Draw method
drawable.Draw();      // "Drawing on screen"
printable.Draw();     // "Drawing on paper"
```

**Mixed Approach**  
You can combine both approaches:
```csharp
class Document : IDrawable, IPrintable {
    public void Draw() {
        Console.WriteLine("Default drawing");
    }
    
    void IPrintable.Draw() {
        Console.WriteLine("Drawing on paper");
    }
}

// IDrawable uses the public method, IPrintable uses explicit implementation
Document doc = new Document();
IDrawable drawable = doc;
IPrintable printable = doc;

doc.Draw();        // "Default drawing"
drawable.Draw();   // "Default drawing"
printable.Draw();  // "Drawing on paper"
```

**Resolution Rules**  

- **Explicit implementations take precedence** when called through their specific interface reference
- **Public implementations** are used when called directly on the object or through interfaces that don't have explicit implementations
- **Compile-time resolution** - the compiler determines which method to call based on the reference type, not the runtime type
- **No ambiguity errors** - unlike some languages, C# handles this gracefully through its interface implementation system  

This design allows you to implement interfaces with conflicting method signatures while maintaining type safety and clear semantics about which method gets called in each context.

---

### Q. How does C# support polymorphism through inheritance?  
Inheritance-based polymorphism allows you to write flexible, extensible code where the same interface can work with objects of different types, with the correct behavior determined at runtime based on the actual object type.RetryClaude does not have the ability to run the code it generates yet.  
C# supports polymorphism through inheritance in several key ways:  

- **Virtual and Override Keywords**  
    The foundation of polymorphism in C# is the `virtual` and `override` keyword pair. A base class method marked as `virtual` can be overridden in derived classes using the `override` keyword:
    ```csharp
    public class Animal {
        public virtual void MakeSound() {
            Console.WriteLine("Some generic animal sound");
        }
    }

    public class Dog : Animal{
        public override void MakeSound() {
            Console.WriteLine("Woof!");
        }
    }

    public class Cat : Animal {
        public override void MakeSound() {
            Console.WriteLine("Meow!");
        }
    }
    ```

- **Runtime Method Resolution**  
    When you call a method on a base class reference that points to a derived class object, C# uses the actual object's type to determine which method to call:  
    ```csharp
    Animal[] animals = { new Dog(), new Cat(), new Animal() };

    foreach (Animal animal in animals) {
        animal.MakeSound(); // Calls the appropriate override based on actual type
    }
    // Output: "Woof!", "Meow!", "Some generic animal sound"
    ```

- **Abstract Classes and Methods**  
    Abstract classes provide a stronger form of polymorphism by forcing derived classes to implement certain methods:  
    ```csharp
    public abstract class Shape {
        public abstract double CalculateArea();
        
        public virtual void Display() {
            Console.WriteLine($"Area: {CalculateArea()}");
        }
    }

    public class Circle : Shape {
        private double radius;
        
        public Circle(double radius) => this.radius = radius;
        
        public override double CalculateArea() {
            return Math.PI * radius * radius;
        }
    }
    ```

- **Interface Implementation**  
    Interfaces define contracts that implementing classes must fulfill, enabling polymorphism across unrelated class hierarchies:  
    ```csharp
    public interface IDrawable {
        void Draw();
    }

    public class Rectangle : Shape, IDrawable {
        public override double CalculateArea() { /* implementation */ }
        
        public void Draw() {
            Console.WriteLine("Drawing rectangle");
        }
    }
    ```

- **Method Hiding vs. Overriding**  
    C# distinguishes between method overriding (using `override`) and method hiding (using `new`). Method hiding breaks polymorphic behavior:  
    ```csharp
    public class Base {
        public virtual void Method() => Console.WriteLine("Base");
    }

    public class Derived : Base {
        public new void Method() => Console.WriteLine("Derived");
    }

    Base obj = new Derived();
    obj.Method(); // Prints "Base" - polymorphism broken with 'new'
    ```

- **Sealed Methods and Classes**  
    The `sealed` keyword prevents further overriding of methods or inheritance of classes:  
    ```csharp
    public class BaseClass {
        public virtual void Method() { }
    }

    public class MiddleClass : BaseClass {
        public sealed override void Method() { } // Cannot be overridden further
    }
    ```
---

### Q. What is the impact of inheritance on memory allocation in C#?  
Inheritance primarily affects memory allocation for class-based objects (reference types) on the managed heap, where the garbage collector handles lifetime and reclamation. Here are the key impacts of inheritance on memory allocation:

**Object Layout and Memory Structure**  
When you create an instance of a derived class, memory is allocated for the entire object hierarchy. The object contains fields from the base class first, followed by fields from derived classes in order of inheritance. This creates a single, contiguous memory block that includes all inherited members.
```csharp
class Animal { int age; }
class Dog : Animal { string breed; }
// A Dog instance allocates memory for both 'age' and 'breed'
```

**Increased Memory Footprint**  
Derived classes typically require more memory than their base classes because they inherit all base class fields plus their own. This can lead to larger object sizes, especially in deep inheritance hierarchies. Each level of inheritance potentially adds more fields and thus more memory overhead.  

**Virtual Method Table (vtable) Overhead**  
Objects from classes with virtual methods include a pointer to a virtual method table. This adds a small but consistent memory overhead (typically 8 bytes on 64-bit systems) to each instance. The vtable itself is shared among all instances of the same type, but each object needs the pointer.  

**Boxing and Reference Types**  
Inheritance affects how value types and reference types are handled. When you cast a derived class to a base class reference, no additional memory allocation occurs for reference types - you're just changing how you view the same object. However, boxing value types that implement interfaces does create new heap allocations.
```csharp
struct MyStruct : IComparable {
    public int Value;
    
    public int CompareTo(object obj) {
        // implementation
    }
}

MyStruct myValue = new MyStruct { Value = 42 };

// This causes BOXING - new heap allocation!
IComparable comparable = myValue;  // myValue gets boxed into an object

// This also causes boxing
object obj = myValue;  // Boxing again
```
i.e. When you have polymorphic collections or use interfaces, boxing can happen without you realizing:
```csharp
// This creates boxing for each struct!
IComparable[] items = { myStruct1, myStruct2, myStruct3 };

// Each struct gets boxed into a separate heap object
// Memory allocation happens for each one
```

**Garbage Collection Implications**  
Inheritance can impact garbage collection in several ways:  
- Objects with finalizers (destructors) require additional GC cycles
- Deep inheritance hierarchies might create more complex object graphs
- Polymorphic collections can hold references to objects of varying sizes, potentially affecting heap fragmentation  

**Memory Efficiency Considerations**  
While inheritance provides code reuse and polymorphism benefits, it can sometimes lead to memory inefficiency if base classes contain fields that aren't needed by all derived classes. In such cases, composition might be more memory-efficient than inheritance.  
The key is understanding that inheritance creates "is-a" relationships that are reflected in memory layout, where derived objects carry the full weight of their inheritance hierarchy in terms of both functionality and memory footprint.  

---

### Q. What are potential drawbacks of deep inheritance hierarchies?  

**Complexity and Maintainability**  
As hierarchies grow deeper, understanding the complete behavior of a class requires tracing through multiple ancestor classes. This makes the codebase harder to comprehend, debug, and modify. Changes to parent classes can have unexpected ripple effects throughout the hierarchy.  

**Tight Coupling**  
Deep inheritance creates strong dependencies between classes across multiple levels. Child classes become tightly coupled not just to their immediate parent, but to the entire chain of ancestors. This makes the system fragile and resistant to change.

**Fragile Base Class Problem**  
Modifications to base classes can break derived classes in subtle ways. When inheritance chains are deep, these breaking changes can propagate through many levels, affecting classes that seem unrelated to the original change.  

**Inflexibility**  
Deep hierarchies lock you into rigid structures that are difficult to refactor. If you need to reorganize the hierarchy or extract common functionality differently, the deeply nested relationships make such changes extremely costly.  

**Method Resolution Complexity**  
In deep hierarchies, determining which version of a method gets called becomes increasingly complex, especially with method overriding. This can lead to confusing runtime behavior and difficult-to-trace bugs.  

**Violation of Composition Over Inheritance**  
Deep inheritance often indicates missed opportunities to use composition instead. Composition provides more flexibility, better testability, and clearer relationships between components.  

**Testing Difficulties**  
Testing classes deep in an inheritance hierarchy becomes challenging because you need to understand and potentially mock the entire chain of dependencies. Unit testing becomes more complex when classes carry heavy inheritance baggage.  

The general recommendation is to favor composition over inheritance and keep inheritance hierarchies shallow (typically no more than 3-4 levels deep) to maintain code clarity and flexibility.

---

### Q. When would you choose inheritance over composition in a C# project?  
In a C# project, choosing between **inheritance** and **composition** depends on the specific design requirements, relationships between classes, and the principles of object-oriented programming. Here's a clear breakdown:  

**When to Choose Inheritance**  
Inheritance is the right choice when there is a clear "is-a" relationship between classes, and you want to model a strong, hierarchical relationship where a derived class is a specialized version of a base class. Use inheritance when: 

1. **Strong "Is-A" Relationship**:   
    - The derived class is a specific type of the base class, and this relationship is natural and unlikely to change.
    - Example: A `Dog` class inheriting from an `Animal` class because a dog *is an* animal.

2. **Shared Behavior and State**:  
    - The base class provides common behavior or state that all derived classes naturally share, and you want to avoid duplicating code.
      - Example: A `Vehicle` base class with properties like `Speed` and methods like `Move()` that apply to `Car`, `Truck`, and `Bicycle`.

3. **Polymorphism is Needed**:
    - You need to leverage polymorphism, where derived classes can override base class methods to provide specific implementations, and you want to treat all derived classes as instances of the base class.
    - Example: A `Shape` base class with a virtual `Draw()` method overridden by `Circle` and `Rectangle`.
    ```csharp
    public abstract class Shape {
        public virtual void Draw() { Console.WriteLine("Drawing a shape"); }
    }

    public class Circle : Shape {
        public override void Draw() { Console.WriteLine("Drawing a circle"); }
    }
    ```

4. **Framework or Library Requirements**:
    - Some frameworks (e.g., ASP.NET, WPF) require inheritance to extend base classes like `Controller` or `Window` to hook into their lifecycle or functionality.
    - Example: In ASP.NET, a custom controller must inherit from `ControllerBase` to integrate with the framework.

**When to Avoid Inheritance**  
- The relationship is more of a "has-a" or "uses-a" instead of "is-a" (e.g., a `Car` has an `Engine`, not is an `Engine`).
- The base class is likely to change frequently, as this can break derived classes (violating the Liskov Substitution Principle).
- You need flexibility to swap or modify behavior at runtime, which composition handles better.
- The hierarchy becomes overly complex or deep, leading to maintenance issues.

**Why Composition is Often Preferred**  
- Promotes loose coupling by allowing components to be swapped or modified without affecting the containing class.
- Supports runtime behavior changes (e.g., using dependency injection).
- Avoids the fragility of deep inheritance hierarchies.
- Aligns better with "has-a" relationships.

Example of composition:
```csharp
public class Engine {
    public void Start() { Console.WriteLine("Engine started"); }
}

public class Car {
    private readonly Engine _engine;
    public Car(Engine engine) => _engine = engine;
    public void Drive() => _engine.Start();
}
```
---
