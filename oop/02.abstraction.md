# Abstraction
Abstraction is a principle that focuses on hiding the complex implementation details of a class while exposing only the essential features or behaviors to the outside world. It allows developers to work with simplified models of objects, focusing on *what* an object does rather than *how* it does it.

## ðŸŽ¯ Goals of Abstraction
- **Hide Implementation Details**:
  - Users of a class donâ€™t need to know how methods or properties work internally.
  - They only interact with a **clear, defined interface**.
  - *Example*: You can use a `List<T>` without knowing how it resizes internally.
- **Reduce Complexity**:
  - By focusing only on **what** an object does, not **how**, the system becomes easier to understand and manage.
  - *Like a remote control*: You press a button â€” you donâ€™t worry about how the signal is processed.
- **Improve Code Maintainability**:
  - Changes to internal logic can be made **without affecting** the classes or code that use it â€” as long as the interface contract remains the same.
- **Enhance Code Reusability**:
  - Abstract structures (like abstract classes or interfaces) can be reused across multiple implementations.
  - *Example*: Interface `ILogger` can be implemented by `FileLogger`, `ConsoleLogger`, etc.
- **Enable Loose Coupling**:
  - Abstraction decouples high-level logic from low-level implementation.
  - Makes code **more modular** and easier to replace or extend.
  - *Example*: Switching from one database to another by abstracting the data access layer.
- **Support Polymorphism**:
  - Abstraction (through interfaces or base classes) enables objects to be used interchangeably via a common type.
  - *Example*: A method that accepts a `Shape` can work with `Circle`, `Square`, etc., without knowing their specific types.

## âœ… Ways C# supports abstraction:

### 1. Abstract Classes 
- Define a base class with common functionality, leaving some members unimplemented for derived classes.
- Cannot be instantiated directly.
```cs
public abstract class Animal
{
    public abstract void MakeSound(); // Abstract method
    public void Breathe() => Console.WriteLine("Breathing...");
}

public class Dog : Animal
{
    public override void MakeSound() => Console.WriteLine("Bark!");
}

```

### 2. Interfaces
- Define a contract that implementing classes must follow.
- No implementation (prior to C# 8.0); just signatures.
```cs
public interface IVehicle
{
    void Drive();
}

public class Car : IVehicle
{
    public void Drive() => Console.WriteLine("Driving car...");
}
```

### 3. Access Modifiers (Encapsulation aiding Abstraction)
- Hide internal class members and expose only what's needed.
- `public`, `private`, `protected`, `internal`, `protected internal`, `private protected`
```cs
public class BankAccount
{
    private decimal balance; // Hidden implementation
    public void Deposit(decimal amount) => balance += amount; // Public API
}
```

### 4. Delegates and Events
Delegates and events allow you to abstract method invocation so that caller doesn't know who handles the operation.
```cs
public delegate void Notify();  // Delegate declaration

class Process
{
    public event Notify ProcessCompleted;  // Event using delegate

    public void Start()
    {
        Console.WriteLine("Process started...");
        // Some logic
        ProcessCompleted?.Invoke();  // Raise event
    }
}

class Program
{
    static void Main()
    {
        Process p = new Process();
        p.ProcessCompleted += () => Console.WriteLine("Process completed.");
        p.Start();
    }
}
```

### 5. Virtual Methods and Method Overriding
- Virtual methods allow derived classes to override base class implementations, enabling abstraction by letting subclasses redefine behavior while adhering to a common interface.
- **Use Case**: To provide a default implementation that can be customized by derived classes.
```cs
class Vehicle
{
    public virtual void Start()
    {
        Console.WriteLine("Vehicle starting...");
    }
}

class Car : Vehicle
{
    public override void Start()
    {
        Console.WriteLine("Car engine revving!");
    }
}
```

## Interview Questions

### Q. What is an abstract class? Can it have concrete methods? Can it have constructors?  
An abstract class in C# is a class that cannot be instantiated directly and serves as a blueprint for derived classes. It is designed to define common behavior and structure for a group of related classes, often encapsulating shared functionality while leaving specific implementations to subclasses. Abstract classes are declared using the `abstract` keyword and are used to achieve abstraction in object-oriented programming by focusing on "what" a class does rather than "how" it does it.  

- Key Characteristics:
  - Cannot be instantiated (e.g., `new AbstractClass()` is not allowed).
  - Can contain **abstract members** (methods, properties, etc.) that have no implementation and must be implemented by derived classes.
  - Can contain **concrete members** (methods, properties, fields, etc.) with full implementations.
  - Used as a base class for inheritance.
  
```cs
abstract class Animal
{
    public abstract void MakeSound(); // Abstract method (no implementation)
}

class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}

// Usage
Dog dog = new Dog();
dog.MakeSound(); // Output: Woof!
// Animal animal = new Animal(); // Error: Cannot instantiate abstract class
```

An abstract class can have **concrete methods** (methods with full implementation). These methods provide shared functionality that derived classes can use as-is or override (if marked as `virtual`). This allows abstract classes to define common behavior while still enforcing abstraction for specific methods.
```cs
abstract class Vehicle
{
    public abstract void StartEngine(); // Abstract method
    public void Stop() // Concrete method
    {
        Console.WriteLine("Vehicle stopped.");
    }
}

class Car : Vehicle
{
    public override void StartEngine()
    {
        Console.WriteLine("Car engine started.");
    }
}

// Usage
Car car = new Car();
car.StartEngine(); // Output: Car engine started.
car.Stop();        // Output: Vehicle stopped.
```

An abstract class can have **constructors**, which are used to initialize fields or properties when a derived class is instantiated. Since an abstract class cannot be instantiated directly, its constructor is called by the derived class' constructor (explicitly or implicitly). Constructors in abstract classes are typically used to enforce initialization logic for shared fields.
```cs
abstract class Shape
{
    protected string color;
    public Shape(string color) // Constructor
    {
        this.color = color;
    }
    public abstract double CalculateArea();
    public void DisplayColor()
    {
        Console.WriteLine($"Color: {color}");
    }
}

class Rectangle : Shape
{
    private double width, height;
    public Rectangle(string color, double width, double height) : base(color)
    {
        this.width = width;
        this.height = height;
    }
    public override double CalculateArea()
    {
        return width * height;
    }
}

// Usage
Rectangle rect = new Rectangle("Blue", 5, 3);
rect.DisplayColor(); // Output: Color: Blue
Console.WriteLine(rect.CalculateArea()); // Output: 15
```
The abstract class `Shape` has a constructor that initializes the `color` field. The `Rectangle` class calls this constructor using `base(color)` to ensure the `color` field is set when a `Rectangle` object is created.

---

### Q. What is an interface? Can a class implement multiple interfaces?  
An interface in C# is a contract that defines a set of methods, properties, events, or indexers that a class or struct must implement, without providing any implementation details. It focuses on "what" must be done, not "how" it is done, promoting abstraction and loose coupling in object-oriented programming. Interfaces are declared using the `interface` keyword and are typically used to ensure that different classes adhere to a common set of behaviors.

- Key Characteristics:
  - Contains only member declarations (no implementation until C# 8.0 introduced default implementations, which are rarely used).
  - Cannot be instantiated directly.
  - Classes or structs that implement an interface must provide implementations for all its members.
  - Supports polymorphism by allowing objects to be treated as the interface type.
```cs
interface IAnimal
{
    void MakeSound(); // Method signature
    string Name { get; set; } // Property signature
}

class Dog : IAnimal
{
    public string Name { get; set; }
    public void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}

// Usage
IAnimal dog = new Dog { Name = "Buddy" };
dog.MakeSound(); // Output: Woof!
Console.WriteLine(dog.Name); // Output: Buddy
```

A class in C# can implement **multiple interfaces**. This is a key feature that allows a class to conform to multiple contracts, enabling flexible design and supporting multiple behaviors. Unlike inheritance, where a class can only inherit from one base class, a class can implement any number of interfaces by separating them with commas in the class declaration.
- Key Points:
  - Each interfaceâ€™s members must be implemented by the class.
  - Multiple interface implementation is useful for combining unrelated behaviors (e.g., a class can be both `IDisposable` and `IComparable`).
  - If interfaces have conflicting member names, explicit interface implementation can be used to resolve ambiguity.
```cs
interface IPrinter
{
    void Print();
}

interface IScanner
{
    void Print();
}

class MultiFunctionDevice : IPrinter, IScanner
{
    void IPrinter.Print()
    {
        Console.WriteLine("Printing document...");
    }

    void IScanner.Print()
    {
        Console.WriteLine("Printing scanned image...");
    }
}

// Usage
MultiFunctionDevice device = new MultiFunctionDevice();
((IPrinter)device).Print(); // Output: Printing document...
((IScanner)device).Print(); // Output: Printing scanned image...
```

---

### Q. When would you use an abstract class instead of an interface?
An abstract class is used instead of an interface when you want to provide a common base with shared implementation, state, or behavior that derived classes can inherit. Here are some scenarios where an abstract class is preferred over an interface:  

**1. Shared Implementation**:  
Abstract classes can contain concrete methods, fields, and properties with shared implementation, which derived classes can use or override.  
Interfaces (prior to C# 8.0) only define contracts without implementation, and even with default implementations in C# 8.0+, they are less suited for sharing complex logic.
```cs
abstract class Vehicle
{
    protected int speed; // Shared state
    public void Stop() // Shared concrete method
    {
        speed = 0;
        Console.WriteLine("Vehicle stopped.");
    }
    public abstract void Drive(); // Abstract method for specific behavior
}

class Car : Vehicle
{
    public override void Drive()
    {
        speed = 60;
        Console.WriteLine($"Car driving at {speed} km/h.");
    }
}

// Usage
Car car = new Car();
car.Drive(); // Output: Car driving at 60 km/h.
car.Stop();  // Output: Vehicle stopped.
```
The `Stop` method and `speed` field are shared across all `Vehicle` types, avoiding code duplication. An interface would require each class to implement `Stop` independently.

**2. State Management**:
Abstract classes can maintain state through fields (e.g., private or protected variables), properties, or methods, allowing derived classes to inherit and manipulate shared data.
Interfaces cannot hold state; they only define behavior.
```cs
abstract class Shape
{
    protected string color; // Field to store state
    public Shape(string color)
    {
        this.color = color;
    }
    public abstract double CalculateArea();
    public string GetColor() => color; // Shared method
}

class Circle : Shape
{
    private double radius;
    public Circle(string color, double radius) : base(color)
    {
        this.radius = radius;
    }
    public override double CalculateArea()
    {
        return Math.PI * radius * radius;
    }
}

// Usage
Circle circle = new Circle("Red", 5);
Console.WriteLine(circle.GetColor()); // Output: Red
Console.WriteLine(circle.CalculateArea()); // Output: 78.54
```
The `color` field and `GetColor` method are shared, and the constructor enforces initialization. An interface cannot store fields or enforce such initialization.

**3. Access Modifiers**:
Abstract classes can use access modifiers (`private`, `protected`, `internal`, etc.) to control visibility of members, allowing finer control over encapsulation. Interfaces typically have public members (implicitly or explicitly).
```cs
abstract class Appliance
{
    protected bool isOn; // Protected field
    protected void Reset() // Protected method
    {
        isOn = false;
        Console.WriteLine("Appliance reset.");
    }
    public abstract void Operate();
}

class Fan : Appliance
{
    public override void Operate()
    {
        isOn = true;
        Console.WriteLine("Fan is spinning.");
    }
    public void Stop()
    {
        Reset(); // Access protected method
        Console.WriteLine("Fan stopped.");
    }
}

// Usage
Fan fan = new Fan();
fan.Operate(); // Output: Fan is spinning.
fan.Stop();    // Output: Appliance reset. Fan stopped.
```
The `Reset` method is `protected`, accessible only to derived classes, ensuring controlled access. Interfaces cannot have protected members. 

> However, with C# 8.0 and later, default interface implementations allow for `private`, `protected`, `internal`, `public`, `virtual`, `abstract`, `sealed`, `static`, `extern`, and `partial` modifiers on members under specific conditions.  
> For example, a private method with a default implementation can be added to an interface.

---

### Q. Can an abstract class implement an interface?
- Yes, An abstract class can implement some or all of the interface's members (methods, properties, etc.).
- If the abstract class does not implement all interface members, it must declare the unimplemented members as `abstract`, and derived classes must provide the implementations.
- This approach combines the benefits of interfaces (defining contracts) with abstract classes (shared state and implementation).

**1. Abstract Class Fully Implements the Interface**  
The abstract class provides concrete implementations for all interface members, and derived classes inherit these implementations.
```cs
interface IDrawable
{
    void Draw();
}

abstract class Shape : IDrawable
{
    protected string color;
    public Shape(string color)
    {
        this.color = color;
    }
    public void Draw() // Concrete implementation of interface method
    {
        Console.WriteLine($"Drawing a {color} shape.");
    }
}

class Circle : Shape
{
    public Circle(string color) : base(color) { }
}

// Usage
Circle circle = new Circle("Red");
circle.Draw(); // Output: Drawing a Red shape.
```
**Explanation**: The `Shape` abstract class implements the `IDrawable` interface by providing a concrete `Draw` method. The `Circle` class inherits this implementation without needing to override it.  

**2. Abstract Class Partially Implements the Interface**  
The abstract class implements some interface members and leaves others as abstract, requiring derived classes to implement them.
```cs
interface IVehicle
{
    void Start();
    void Stop();
}

abstract class Vehicle : IVehicle
{
    protected string model;
    public Vehicle(string model)
    {
        this.model = model;
    }
    public void Stop() // Concrete implementation
    {
        Console.WriteLine($"{model} stopped.");
    }
    public abstract void Start(); // Abstract method for interface member
}

class Car : Vehicle
{
    public Car(string model) : base(model) { }
    public override void Start() // Must implement the abstract method
    {
        Console.WriteLine($"{model} engine started.");
    }
}

// Usage
Car car = new Car("Toyota");
car.Start(); // Output: Toyota engine started.
car.Stop();  // Output: Toyota stopped.
```
**Explanation**: The `Vehicle` abstract class implements the `IVehicle` interface, providing a concrete `Stop` method but leaving `Start` as abstract. The `Car` class must implement `Start`.  

**3. Abstract Class Implements Multiple Interfaces**  
An abstract class can implement multiple interfaces, either fully or partially, just like any other class.
```cs
interface IMovable
{
    void Move();
}

interface IDescribable
{
    string GetDescription();
}

abstract class Animal : IMovable, IDescribable
{
    protected string name;
    public Animal(string name)
    {
        this.name = name;
    }
    public void Move() // Concrete implementation
    {
        Console.WriteLine($"{name} is moving.");
    }
    public abstract string GetDescription(); // Abstract method
}

class Dog : Animal
{
    public Dog(string name) : base(name) { }
    public override string GetDescription()
    {
        return $"A dog named {name}.";
    }
}

// Usage
Dog dog = new Dog("Buddy");
dog.Move(); // Output: Buddy is moving.
Console.WriteLine(dog.GetDescription()); // Output: A dog named Buddy.
```
**Explanation**: The `Animal` abstract class implements both `IMovable` and `IDescribable` interfaces, providing a concrete `Move` method and leaving `GetDescription` as abstract for derived classes like `Dog` to implement.

---
### Q. What are default interface methods in C# 8.0+?
Default interface methods are methods with implementation defined directly within an interface. Before C# 8.0, interfaces could only contain method declarations, but now they can include both the declaration and the method body. These methods are also known as **virtual extension methods**.
```cs
public interface ILogger 
{
    void Log(string info); // Abstract method (traditional)
    
    // Default interface method with implementation
    public void LogInfo(string typeofInformation, string info) 
    {
        Console.Write(typeofInformation + " " + info);
    }
}
```
- Default interface methods are virtual by default, allowing them to be overridden in derived interfaces
- They support various access modifiers: private, protected, internal, public, virtual, abstract, override, sealed, static, and extern
- The explicit access modifier for default methods is public if no modifier is specified  

**Inheritance Behavior:**  
A crucial aspect of default interface methods is that **implementing classes don't automatically inherit them**. The class doesn't know about the existence of default methods and doesn't contain their implementation. To access default methods, you must cast the object to the interface type
```cs
public class TextLogger : ILogger 
{
    public void Log(string info) => Console.Write("In base Logger");
}

// Usage
TextLogger logger = new TextLogger();
// logger.LogInfo(...); // This won't work

ILogger interfaceLogger = logger;
interfaceLogger.LogInfo("Test", "message"); // This works
```
**API Evolution Without Breaking Changes:**  
The main advantage is backward compatibility. API authors can add new methods to existing interfaces without breaking existing implementations. This solves a long-standing problem where adding methods to interfaces would force all implementing classes to be updated.

---

### Q. What is the use of protected members in C# interfaces?
In C# 8.0 and later, interfaces can have protected members.  
However, unlike classes, where protected allows access within the same class and derived classes, the purpose and usage of protected members in interfaces are a bit different.  
- **Access is limited to derived interfaces, not derived classes**: A `protected` member in an interface can only be accessed by interfaces that inherit from it. Classes that implement the interface cannot directly access these `protected` members.
- **Explicit implementation required**: When a class implements an interface with `protected` members, it needs to explicitly implement those members, meaning the implementation must be qualified with the interface name.  
  
**Potential Use Cases**  
While less common than in classes, `protected` interface members can be useful in **scenarios involving interface hierarchies** where you want to provide helper methods or properties that are only relevant to the internal implementation details of derived interfaces.  
For example, consider a situation where you have a base interface `IInventoryController` with a `protected` method `PullInventoryItem()`. Derived interfaces could then utilize this protected method for their internal logic, without exposing it to classes that simply implement the interface.  

> The primary purpose of interfaces remains defining contracts and abstracting behavior. Overusing default implementations and `protected` members might make interfaces behave more like abstract classes, potentially blurring the lines between these two concepts.

---

### Q. How is abstraction achieved in functional programming in C#?  
Abstraction in functional programming in C# is about hiding the complex implementation details and exposing only the necessary functionalities to the user. While C# is traditionally an object-oriented language, it has strong support for functional programming paradigms where abstraction is primarily achieved through **higher-order functions**, **delegates**, and **LINQ abstractions**.  

**1. Higher-Order Functions**   
Higher-order functions are functions that take other functions as arguments or return them as results. This allows you to abstract over behaviors, not just data.  
Example: Using `Func<T, TResult>` to Abstract Behavior
```cs
// Higher-order function that performs an operation on two integers
int Compute(int a, int b, Func<int, int, int> operation)
{
    return operation(a, b);
}

// Usage:
int sum = Compute(3, 4, (x, y) => x + y);        // sum = 7
int product = Compute(3, 4, (x, y) => x * y);    // product = 12
```
Here, the implementation details of addition or multiplication are abstracted away, and you can pass any operation you need at the call site.

**2. Delegates and Lambdas**  
Delegates and lambda expressions let you treat functions as first-class objects, further enabling abstraction by decoupling what is done from how it is done.
```cs
// Define a delegate
public delegate bool Criteria(int value);

// Abstracted filter function
IEnumerable<int> Filter(IEnumerable<int> numbers, Criteria criteria)
{
    foreach (var n in numbers)
    {
        if (criteria(n)) yield return n;
    }
}

// Usage:
var oddNumbers = Filter(new[] {1, 2, 3, 4, 5}, x => x % 2 != 0);
```

**3. LINQ as Functional Abstraction**  
LINQ provides a high-level and expressive way to abstract data transformation pipelines.
```cs
var squares = numbers.Select(n => n * n);  // abstracts away explicit iteration
```

**4. Using Interfaces and Abstract Classes**  
While more common in OOP, interfaces and abstract classes can also serve as abstractions in functional style, especially when you expose only behaviors without implementation details.
```cs
public interface IOperation
{
    int Apply(int x, int y);
}

public class Addition : IOperation
{
    public int Apply(int x, int y) => x + y;
}

public class Multiplication : IOperation
{
    public int Apply(int x, int y) => x * y;
}

// Usage:
IOperation op = new Addition();
int result = op.Apply(2, 3); // result = 5
```
This allows you to pass operations around abstractly, without needing to know their concrete implementation.

---
