# Encapsulation
It refers to the **bundling of data (fields) and methods (functions)** that operate on the data into a single unit (a class), while controlling the access to object's internal state through access modifiers.

## ðŸŽ¯ Goals of Encapsulation
- **Protect internal state** of an object from unintended or harmful changes.
- **Provide controlled access** through methods or properties (getters/setters).
- **Improve maintainability** and modularity of the code.
- Support **data validation**, consistency, and integrity.

## âœ… Ways C# supports encapsulation:

### 1. Access Modifiers  
These control the visibility of class members (fields, properties, methods, etc.) from other parts of the code.  
- `private`: Fields or methods are accessible only within the same class. This is the default for fields to hide them from external access.
- `public`: Members are accessible from everywhere. Used for methods that form the public interface.
- `protected`: Members are accessible within the class and its derived classes.
- `internal`: Members are accessible within the same assembly.
- `protected internal`: Members are accessible within the same assembly or derived classes in other assemblies.
- `private protected`: Members are accessible only within the class and derived classes in the same assembly.  

By marking fields as `private` (or similar), you prevent direct external access, a core principle of encapsulation.  

```cs
class Car{
    private int speed; // Cannot be accessed directly outside

    public void SetSpeed(int value){
        if (value >= 0) speed = value;
    }

    public int GetSpeed() {
        return speed;
    }
}

```

### 2. Properties
C# provides a cleaner syntax using properties with get/set accessors to encapsulate fields while still exposing them safely.  
```cs
class Car {
    private int _speed;

    public int Speed {
        get { return _speed; }
        set {
            if (value >= 0) _speed = value;
        }
    }
}

```
Or using **auto-implemented properties** with access control:
```cs
public class Person
{
    public string Name { get; private set; } // Readable from outside, writable only inside
}

```

### 3. Methods
Encapsulation often involves exposing functionality through **public methods**, while keeping the implementation **private**.  
```cs
class BankAccount {
    private decimal balance;

    public void Deposit(decimal amount) {
        if (amount > 0) balance += amount;
    }

    public decimal GetBalance() {
        return balance;
    }
}
```

### 4. Interfaces and Abstraction
While abstraction and encapsulation are distinct, interfaces support encapsulation by hiding the classâ€™s internal details related to implementation.  
```cs
public interface ILogger {
    void Log(string message);
}

public class FileLogger : ILogger {
    private string logFilePath = "log.txt"; // hidden implementation data

    public void Log(string message) {
        // writes to file
    }
}
```

### 5. Private/Internal Classes and Nested Types
You can restrict access to certain classes entirely by marking them `private` or `internal`.
```cs
public class OuterClass {
    private class InnerHelper {
        public void DoWork() { }
    }
}
```

## Interview Questions
---
### Q. What is encapsulation in OOP? How is it different from abstraction?
**Encapsulation** in Object-Oriented Programming (OOP) is the bundling of data (attributes) and methods (functions) that operate on that data into a single unit, typically a class, while restricting direct access to some of the object's components. Itâ€™s about hiding the internal state of an object and only allowing access through well-defined interfaces, like public methods. This is often achieved using access modifiers (e.g., private, protected, public) to control visibility and ensure data integrity.  
> **Example**: In a `BankAccount` class, the balance is a private attribute. You can only modify it through public methods like `deposit()` or `withdraw()`, which enforce rules (e.g., no negative deposits). This protects the balance from being directly altered in an invalid way.

**Abstraction** in OOP is about hiding complex implementation details and exposing only the essential features of an object to the user. It focuses on *what* an object does, not *how* it does it, often achieved through abstract classes or interfaces.  
> **Example**: A `CoffeeMachine` interface might define a `brew()` method. The user doesnâ€™t need to know the internal mechanics (heating, grinding, etc.)â€”just that calling `brew()` makes coffee.  

Both concepts work together to make OOP systems modular, secure, and user-friendly, but they address different aspects of design.
- **Purpose**:
   - Encapsulation: Protects an objectâ€™s internal state by restricting access and bundling data with methods.
   - Abstraction: Simplifies interaction by hiding complex implementation details and showing only necessary functionality.

- **Focus**:
   - Encapsulation: Focuses on *data security* and bundling.
   - Abstraction: Focuses on *simplifying interaction* and reducing complexity.

**Analogy**:
- Encapsulation is like a locked safe: only specific keys (methods) can access the contents (data).
- Abstraction is like a carâ€™s dashboard: you see simple controls (steering, pedals) without needing to understand the engineâ€™s complexity.

---

### Q. Why is encapsulation important?
Encapsulation enhances security, data integrity, maintainability, and modularity, making OOP systems more robust and easier to manage.  
> **Example**: In a `User` class, encapsulating a `password` field ensures it can only be modified through a `changePassword()` method that enforces security rules (e.g., minimum length, special characters). This protects the system from invalid or insecure password changes.

---

### Q. Can you give an example of encapsulation in C#?
- **Private Fields**: The `balance` field is private, preventing direct access from outside the class.
- **Properties**: The `Balance` property provides controlled read/write access with validation. The `AccountHolder` property is read-only after initialization (`init`).
- **Public Methods**: Methods like `Deposit` and `Withdraw` expose functionality while enforcing rules, keeping the internal state consistent.
- **Constructor**: Initializes the object in a valid state, further supporting encapsulation by ensuring proper setup.

---

### Q. What is the default access modifier for class members in C#? Why is that important for encapsulation?
The default access modifier for class members in C# is `private`. This means that if no access modifier is specified, the member is only accessible within the same class.  
This is important for encapsulation because it ensures that class members are not accessible from outside the class, protecting the internal state of the object and preventing unintended interference.

---


### Q. How do properties support encapsulation in C#?
Properties in C# are a key mechanism for supporting **encapsulation** by providing controlled access to a classâ€™s private fields while maintaining the principles of data hiding and abstraction. They allow a class to expose its data in a safe, flexible, and maintainable way, combining the benefits of direct field access with the ability to enforce validation, logic, or restrictions.  

**1. Controlled Access to Private Fields:**   
Properties act as an intermediary between a classâ€™s private fields and external code. By keeping fields `private` and exposing them through properties, you prevent direct access to the internal state, ensuring data integrity.  
```cs
public class Person
{
    private string name; // Private field

    // Property to control access to name
    public string Name
    {
        get => name; // Allow reading
        set => name = !string.IsNullOrEmpty(value) ? value : throw new ArgumentException("Name cannot be empty.");
    }
}
```
Here, the `Name` property ensures the `name` field cannot be set to an empty or null value, enforcing validation.  

**2. Hiding Implementation Details:**  
Properties allow a class to hide how data is stored or computed. External code interacts with the property as if it were a field, but the class can include logic in the getter or setter without exposing it.
```cs
public class Circle
{
    private double radius;

    public double Radius
    {
        get => radius;
        set => radius = value >= 0 ? value : throw new ArgumentException("Radius cannot be negative.");
    }

    public double Area
    {
        get => Math.PI * radius * radius; // Computed property, no backing field
    }
}
```
The `Area` property is read-only and computed on demand, hiding the calculation logic while encapsulating the `radius` field.

**3. Flexible Access Control:**  
Properties allow fine-grained control over read and write operations. You can make a property read-only (`get` only), write-only (`set` only), or restrict one of them to private/protected access.
```cs
public class BankAccount
{
    private double balance;

    public double Balance
    {
        get => balance; // Public read access
        private set => balance = value >= 0 ? value : throw new ArgumentException("Balance cannot be negative.");
    }

    public void Deposit(double amount)
    {
        if (amount > 0)
            Balance = balance + amount; // Uses private setter
    }
}
```
The `Balance` property allows public reading but restricts modifications to within the class, ensuring controlled updates via methods like `Deposit`.  

**4. Encapsulation Without Changing Interface:**  
Properties allow you to change the internal implementation (e.g., how data is stored or computed) without altering the public interface. External code continues to access the property as if it were a field.
```cs
public class Employee
{
    private string firstName;
    private string lastName;

    public string FullName
    {
        get => $"{firstName} {lastName}"; // Combines two fields
        set
        {
            var parts = value.Split(' ');
            if (parts.Length >= 2)
            {
                firstName = parts[0];
                lastName = parts[1];
            }
            else
            {
                throw new ArgumentException("Full name must include first and last names.");
            }
        }
    }
}
```
External code uses `FullName` as a single property, unaware of the two underlying fields (`firstName`, `lastName`). If the storage changes (e.g., to a single field), the propertyâ€™s interface remains unchanged.  

**5. Auto-Implemented Properties for Simplicity:**  
For simple cases where no additional logic is needed, C# provides **auto-implemented properties**, which automatically create a private backing field. This simplifies code while maintaining encapsulation.
```cs
public class Product
{
    public string Name { get; set; } // Auto-implemented property
    public decimal Price { get; private set; } // Read-only externally

    public void UpdatePrice(decimal newPrice)
    {
        if (newPrice >= 0)
            Price = newPrice;
    }
}
```
The `Price` property is read-only outside the class, and updates are controlled via `UpdatePrice`, ensuring encapsulation.

**6. Support for Immutability:**  
Using `init`-only properties (introduced in C# 9.0), you can create immutable objects where properties can only be set during object initialization, further enhancing encapsulation by preventing unintended changes.
```cs
public class Order
{
    public int OrderId { get; init; } // Can only be set during initialization
    public DateTime OrderDate { get; init; }
}
```

---

### Q. Whatâ€™s the difference between a field and a property in terms of encapsulation? ####  
A **field** is a variable directly declared within a class or struct, typically used to store the internal state of an object.  
A **property** is a class member that provides a controlled interface to access or modify a field (or computed data) through getter and setter methods.  

| Aspect                  | Field                                  | Property                              |
|-------------------------|----------------------------------------|---------------------------------------|
| **Access Control**      | Direct access unless private; no fine-grained control. | Controlled access via `get`/`set`, can be read-only, write-only, or restricted (e.g., `private set`). |
| **Data Hiding**         | Private fields hide data, but public fields expose it completely. | Properties hide the backing field and expose only the intended interface. |
| **Validation/Logic**    | No built-in way to validate or add logic when accessing/modifying. | Getters/setters can include validation, computation, or side effects. |
| **Interface Stability** | Changing a public field to a property breaks the public interface (binary compatibility issue). | Properties maintain a stable interface, allowing internal changes without affecting external code. |
| **Encapsulation Level** | Basic encapsulation with private fields; none with public fields. | Strong encapsulation, even with public properties, due to controlled access and logic. |

---

### Q. What access modifier would you use for a variable that should only be modified inside the class?    
Use the `private` access modifier for a variable that should only be modified inside the class, and optionally expose controlled access via methods or a **property with a private setter**.

---

### Q. When would you make a property read-only or write-only? ####  
**Read-Only Properties:** Use when you want to allow reading but prevent modification, ensuring immutability, computed values, or controlled state exposure. Implemented with `get` only, `private set`, or `init`.  
**Write-Only Properties:** Use for sensitive data (e.g., passwords, security tokens) or action-triggering scenarios (e.g., logging, updating internal state) where reading is unnecessary or restricted. Implemented with `set` only.

---

### Q. How do auto-implemented properties relate to encapsulation? ####  
Auto-implemented properties allow you to define a property with a `get` and/or `set` accessor without manually declaring a private backing field. The compiler creates an anonymous private field behind the scenes.  
Syntax: 
```cs
public class Person {
    public string Name { get; set; } // Auto-implemented property
}
```
In this example, the compiler generates a private field (e.g., `<>_name`) and implements the `get` and `set` accessors to interact with it.  

Auto-implemented properties enhance encapsulation in C# by:
- Hiding the compiler-generated private backing field, preventing direct access.
- Allowing controlled access through `get`, `set`, `private set`, or `init` modifiers.
- Maintaining a stable public interface that can be refactored to include logic later.
- Simplifying code while preserving encapsulation principles.  

However, they are best suited for simple scenarios without validation or computed values. For complex logic, manual properties are needed, but auto-implemented properties still provide a strong foundation for encapsulation by ensuring data is accessed through a controlled interface rather than directly via fields.

---

### Q. How would you refactor a class that exposes all its fields as public? ####
To refactor a class with public fields in C# for encapsulation:  
1. Change public fields to `private`.
2. Replace fields with properties (auto-implemented or manual with validation).
3. Add methods for controlled modifications (e.g., `Deposit` for `Balance`).
4. Use `init` or `private set` for immutability or restricted access.
5. Keep property names same as fields for compatibility.

---

### Q. How can encapsulation help in a team environment when multiple developers are working on the same codebase?
Encapsulation enhances collaboration in a team environment with multiple developers by promoting **modularity**, **data protection**, and **clear interfaces**, which reduce errors, simplify maintenance, and improve code reliability.  
Hereâ€™s a concise explanation of how encapsulation helps:  
1. Prevents Unintended Modifications:  
A `BankAccount` class with a private `balance` field and public `Deposit`/`Withdraw` methods ensures teammates canâ€™t set `balance` to invalid values.
2. Reduces Conflicts:  
Changing how `balance` is calculated in a `BankAccount` class doesnâ€™t affect code using its public `Balance` property.
3. Improves Maintainability:  
Validation in a property setter (e.g., `private set` for `Balance`) ensures consistent behavior across the teamâ€™s code.
4. Facilitates Division of Work:  
One developer can work on a `Customer` class while another works on a `BankAccount` class, relying on each otherâ€™s public methods without interference.
5. Enhances Code Reusability:  
A `Logger` class with a write-only `Message` property can be reused by multiple developers without exposing its logging mechanism.

---

### Q. Can encapsulation help prevent breaking changes in APIs? How? ####  
- **Library Development**: In a library, encapsulation ensures clients depend only on public properties/methods, allowing internal refactoring without forcing clients to update.
- **Team Collaboration**: Multiple developers can work on the APIâ€™s internals without affecting its public contract, reducing coordination overhead.
- **Long-Term Maintenance**: Encapsulation makes it easier to evolve the API (e.g., adding features, optimizing performance) while maintaining backward compatibility.

---

### Q. What are the drawbacks of too much encapsulation? ####
1. Reduced Flexibility:  
Overly restrictive access (e.g., making everything `private` with no public interface) can hinder legitimate use cases, forcing developers to write workarounds or duplicate code to access needed data.  
**Example**: If a `Balance` property is private with no getter, other classes may need to implement redundant logic to estimate the balance, reducing code reuse.

2. Performance Overhead:  
Wrapping every field access in properties or methods with validation or logic can introduce slight performance costs, especially in performance-critical applications where simple field access would be faster.  

3. Boilerplate Code:  
Over-encapsulation can lead to excessive boilerplate (e.g., getters/setters for every field), increasing code volume and maintenance effort without adding meaningful value.  
**Example**: Auto-implemented properties (`public string Name { get; set; }`) are often sufficient, but over-encapsulation might lead to manual properties with redundant validation for every field.

4. Testing Challenges:  
Excessive encapsulation can make unit testing harder, as private fields and methods are inaccessible. Developers may need to use reflection or expose internal state unnecessarily to test the class.  
**Example**: A private field with no getter requires complex test setups to verify the internal state, increasing test complexity.

---
