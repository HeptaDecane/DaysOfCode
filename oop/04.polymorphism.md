# Polymorphism
Polymorphism is a core concept in object-oriented programming that allows objects of different types to be treated as objects of a common super type, enabling the same method or operation to behave differently based on the object calling it. Polymorphism in C# is primarily achieved through **method overriding** (runtime polymorphism) and **method overloading** (compile-time polymorphism).

## ðŸ”‘ Types of Polymorphism in C#

1. **Compile-time Polymorphism (Static Binding / Early Binding)**
   - Achieved using **method overloading** and **operator overloading**.
   - Which method to call is decided at **compile time**.
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b;
        public int Add(int a, int b, int c) => a + b + c;
    }

    class Program {
        static void Main() {
            Calculator calc = new Calculator();
            Console.WriteLine(calc.Add(2, 3));         // Calls int version
            Console.WriteLine(calc.Add(2.5, 3.5));     // Calls double version
            Console.WriteLine(calc.Add(1, 2, 3));      // Calls 3-parameter version
        }
    }
    ```
2. **Runtime Polymorphism (Dynamic Binding / Late Binding)**
    - Achieved using **method overriding** (with inheritance and `virtual`/`override` keywords).
    - Which method to call is decided at **runtime**, depending on the object type.
    ```csharp
    class Animal {
        public virtual void Speak() {
            Console.WriteLine("The animal makes a sound.");
        }
    }

    class Dog : Animal {
        public override void Speak() {
            Console.WriteLine("The dog barks.");
        }
    }

    class Cat : Animal {
        public override void Speak() {
            Console.WriteLine("The cat meows.");
        }
    }

    class Program {
        static void Main() {
            Animal a1 = new Dog();
            Animal a2 = new Cat();

            a1.Speak(); // Output: The dog barks.
            a2.Speak(); // Output: The cat meows.
        }
    }
    ```

## ðŸŽ¯ Goals of Polymorphism
- **Code Reusability**: 
    - Write general code once, and let derived classes provide their specific behavior.
    - Example: A `List<T>` works with `int`, `string`, `Car`, or any object type, because of polymorphism.

- **Extensibility / Flexibility**:
    - New classes can be added without changing existing code, as long as they implement the same interface or override the base methods.
    - Example: Adding a new `Bird` class with `Speak()` doesnâ€™t require changing the existing `Animal` code.

- **Loose Coupling**:
    - Code depends on **abstractions (interfaces or base classes)** instead of concrete implementations.
    - Makes systems less fragile and easier to modify.

- **Improved Readability**:
    - You can call the same method on different objects, and the behavior is appropriate without extra conditionals (`if` / `switch`).
    - Example: Instead of checking `if (animal is Dog)` everywhere, just call `animal.Speak()` and let polymorphism handle it.

- **Supports "Program to an Interface" Principle**:
    - Allows you to use dependency injection and design patterns effectively (like Strategy, Factory, Adapter).

In short, the goal of polymorphism is to **treat different objects uniformly while letting each object define its own specific behavior**.


## âœ… Ways C# supports polymorphism:

### 1. Compile-time Polymorphism
Achieved at compile time.
- **Method Overloading**: Same method name but different parameter signatures.
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b; // overload
    }
    ```

- **Operator Overloading**: Redefine operators for user-defined types.
    ```csharp
    class Complex {
        public int Real { get; set; }
        public int Imaginary { get; set; }

        public static Complex operator +(Complex c1, Complex c2) 
            => new Complex { Real = c1.Real + c2.Real, Imaginary = c1.Imaginary + c2.Imaginary };
    }
    ```

### 2. Runtime Polymorphism
Achieved at runtime, mainly with **inheritance** and **interfaces**.
- **Method Overriding with `virtual` and `override`**
    ```csharp
    class Animal {
        public virtual void Speak() => Console.WriteLine("Animal speaks");
    }

    class Dog : Animal {
        public override void Speak() => Console.WriteLine("Dog barks");
    }
    ```

- **Abstract Classes and Methods**: Force derived classes to provide implementation.
    ```csharp
    abstract class Shape {
        public abstract void Draw();
    }

    class Circle : Shape {
        public override void Draw() => Console.WriteLine("Drawing Circle");
    }
    ```

- **Interfaces**: Multiple classes implement the same contract. 
    ```csharp
    interface IPayment {
        void Pay(decimal amount);
    }

    class CreditCardPayment : IPayment {
        public void Pay(decimal amount) => Console.WriteLine($"Paid {amount} using Credit Card");
    }
    ```

- **Method Hiding**: Using the `new` keyword. Not true overriding, but allows redefining a method in a derived class.
    ```csharp
    class Base {
        public void Show() => Console.WriteLine("Base Show");
    }

    class Derived : Base {
        public new void Show() => Console.WriteLine("Derived Show");
    }
    ```

### 3. Other Forms of Polymorphism in C#
- **Generics (Parametric Polymorphism)**: Write code that works with any data type.
    ```csharp
    class GenericList<T> {
        private List<T> _items = new List<T>();

        public void Add(T item) => _items.Add(item);
        public T Get(int index) => _items[index];
    }
    ```

- **Delegates and Events**: Allow methods to be passed as parameters, enabling callback mechanisms.
    ```csharp
    public delegate void Notify(string message);

    class Process {
        public Notify OnProcessCompleted;

        public void StartProcess() {
            // Process logic here
            OnProcessCompleted?.Invoke("Process Completed!");
        }
    }
    ```

- **Dynamic Keyword (Dynamic Binding)**: Method resolution happens at runtime, bypassing compile-time checks.
    ```csharp
    dynamic obj = "Hello, World!";
    Console.WriteLine(obj.Length); // Resolved at runtime
    ```

## Interview Questions

### Q. What is polymorphism in C#, and why is it important?
Polymorphism in C# is a fundamental object-oriented programming concept that allows objects of different types to be treated as instances of the same base type, while maintaining their specific behaviors.  

There are several types of polymorphism in C#:    
- **Runtime Polymorphism (Method Overriding)**: This is achieved through inheritance and virtual methods. A base class defines a virtual method, and derived classes can override it with their own implementations.
- **Interface Polymorphism**: Different classes can implement the same interface, allowing them to be used interchangeably.
- **Compile-time Polymorphism (Method Overloading)**: This is achieved by defining multiple methods with the same name but different parameter lists within the same class.  


**Why Polymorphism is Important**  
Polymorphism is essential for writing flexible, maintainable, and scalable object-oriented code. It enables you to design systems that can grow and adapt to new requirements with minimal changes to existing code.  
- **Flexibility and Extensibility**: You can write code that works with **base types or interfaces**, making it easy to add new derived types without changing existing code. This follows the Open/Closed Principle - open for extension, closed for modification.  
- **Code Reusability**: Instead of writing separate methods for each specific type, you can write generic code that works with multiple types.  
- **Maintainability**: Changes to specific implementations don't affect the code that uses them polymorphically. This reduces coupling between components and makes systems easier to maintain.  
- **Abstraction**: Polymorphism allows you to work with objects at a higher level of abstraction, focusing on what they can do rather than their specific implementation details. This makes code more readable and conceptually cleaner.  
- **Design Patterns**: Many important design patterns rely heavily on polymorphism, such as Strategy, Factory, and Template Method patterns. These patterns help solve common programming problems elegantly.  

---

### Q. What are the two types of polymorphism in C#?
**1. Compile-time Polymorphism (Static Polymorphism)**  
This is resolved at compile time and includes:  
- **Method Overloading**: Multiple methods with the same name but different parameters (different number, types, or order of parameters)
- **Operator Overloading**: Defining custom behavior for operators like +, -, ==, etc. for user-defined types

**2. Runtime Polymorphism (Dynamic Polymorphism)**
This is resolved at runtime and is achieved through:  
- **Method Overriding**: Using virtual methods in base classes and override methods in derived classes
- **Interface Implementation**: Implementing interface methods in different classes  

Runtime polymorphism allows you to call the same method on different objects and get different behaviors based on the actual object type at runtime, which is determined through method dispatch using the virtual method table (vtable).

---

### Q. What is the difference between method overloading and method overriding?
**Method Overloading:**  
- **Definition**: Method overloading allows a class to have multiple methods with the **same name** but different **parameter lists** (different number, types, or order of parameters).
- **Purpose**: It provides flexibility to call the same method name with different inputs, improving code readability and reusability.
- **Key Characteristics**:
  - Occurs within the **same class**.
  - Methods must differ in their **signature** (number, type, or order of parameters).
  - The **return type** alone cannot differentiate overloaded methods.
  - It is resolved at **compile time** (static polymorphism).
  - Example:
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b; // Overloaded method
        public int Add(int a, int b, int c) => a + b + c; // Overloaded method
    }
    ```

**Method Overriding:**
- **Definition**: Method overriding allows a **derived class** to provide a specific implementation of a method that is already defined in its **base class**.
- **Purpose**: It enables runtime polymorphism, allowing a derived class to modify or extend the behavior of a base class method.
- **Key Characteristics:**
	- Occurs between a **base class** and a **derived class**.
	- The method in the derived class must have the **same name, parameters, and return type** as the method in the base class.
	- The base class method must be marked with the `virtual` or `abstract` keyword, and the derived class method must use the `override` keyword.
	- It is resolved at **runtime** (dynamic polymorphism).
	- Example:
		```csharp
		class Shape {
			public virtual void Draw() => Console.WriteLine("Drawing a shape");
		}

		class Circle : Shape {
			public override void Draw() => Console.WriteLine("Drawing a circle");
		}
		```

**Key Differences:**  
Aspect | Method Overloading | Method Overriding
--- | --- | ---
Definition | Same method name, different parameter lists. | Same method name, same parameters, different implementation.
Location | Within the same class. | Between base and derived classes.
Polymorphism Type | Compile-time (static). | Runtime (dynamic).
Method Signature | Must differ (parameters). | Must be identical (name, parameters, return type).
Keywords | No special keywords required. | `virtual`/`abstract` in base class, `override` in derived class.
Purpose | Flexibility in method calls with different inputs. | Customize or extend base class behavior.

---

### Q. What is the purpose of the `virtual` and `override` keywords in C#?
**`virtual` Keyword:**  
The `virtual` keyword is used in a base class to indicate that a method can be overridden by derived classes. It allows you to provide a default implementation while giving subclasses the option to provide their own specific implementation.
```csharp
public class Shape {
	public virtual void Draw() {
		Console.WriteLine("Drawing a shape");
	}
}
```

**`override` Keyword:**  
The `override` keyword is used in a derived class to provide a new implementation of a virtual method from the base class. The method signature must exactly match the base class method.
```csharp
public class Circle : Shape {
	public override void Draw() {
		Console.WriteLine("Drawing a circle");
	}
}

public class Square : Shape {
	public override void Draw() {
		Console.WriteLine("Drawing a square");
	}
}
```

**Key Points:**  
- **Polymorphism**: When you have a base class reference pointing to a derived class object, calling a virtual method will execute the overridden version in the derived class, not the base class version.
	```csharp
	Shape circle = new Circle();
	circle.Draw(); // Output: Drawing a circle
	```

- **Method Chaining**: You can call the base class implementation from an overridden method using base.MethodName():
	```csharp
	public class Circle : Shape {
		public override void Draw() {
			base.Draw();	// Call base implementation
			Console.WriteLine("Drawing a circle");
		}
	}
	```
---

### Q. Can you overload methods in C# only by changing the return type? Why or why not?
No, you cannot overload methods in C# by changing only the return type. Method overloading in C# is determined by the method's **signature**, which includes:
1. Method name
2. Number of parameters
3. Type of parameters
4. Order of parameters
The return type is **not** part of the method signature for overloading purposes.

**The Problem with Return-Type-Only Overloading**  
Consider this hypothetical scenario if C# allowed return-type-only overloading:
```csharp
public int Calculate(int x, int y) { return x + y; }
public string Calculate(int x, int y) { return (x + y).ToString(); }
```
Now imagine calling this method:
```csharp
var result = Calculate(5, 10); // Which method should be called?
```
The compiler cannot determine which overload to use because the call site doesn't specify what type the result should be.  
This creates ambiguity that would make the code unpredictable and error-prone.  

**What Actually Works for Overloading**  
```csharp
public int Calculate(int x, int y) { return x + y; }
public int Calculate(double x, double y) { return (int)(x + y); }
public int Calculate(int x, int y, int z) { return x + y + z; }
public int Calculate(string operation, int x, int y)  { 
    return operation == "add" ? x + y : x - y; 
}
```

**Alternative Approaches**  
If you need different return types for similar operations, consider:  
- **Different method names**: `CalculateSum()` and `CalculateDescription()`
- **Generic methods**: Use type parameters to handle different return types
- **Out parameters**: Return multiple values or use tuple returns

---

### Q. What is operator overloading? Give an example.
Operator overloading is a feature that allows you to define custom behavior for operators (like +, -, *, ==, etc.) when they are used with user-defined types such as classes or structs. Instead of operators only working with built-in types like int or string, you can make them work meaningfully with your custom objects.

In C#, you implement operator overloading by defining special static methods in your class using the `operator` keyword.  
Here's a practical example with a `Vector2D` class:
```csharp
public class Vector2D {
    public double X { get; set; }
    public double Y { get; set; }
    
    public Vector2D(double x, double y) {
        X = x;
        Y = y;
    }
    
    // Overload the + operator for vector addition
    public static Vector2D operator +(Vector2D v1, Vector2D v2) {
        return new Vector2D(v1.X + v2.X, v1.Y + v2.Y);
    }
    
    // Overload the - operator for vector subtraction
    public static Vector2D operator -(Vector2D v1, Vector2D v2) {
        return new Vector2D(v1.X - v2.X, v1.Y - v2.Y);
    }
    
    // Overload the * operator for scalar multiplication
    public static Vector2D operator *(Vector2D v, double scalar) {
        return new Vector2D(v.X * scalar, v.Y * scalar);
    }
    
    // Overload the * operator for scalar multiplication (commutative)
    public static Vector2D operator *(double scalar, Vector2D v) {
        return new Vector2D(v.X * scalar, v.Y * scalar);
    }
    
    // Overload the == operator for equality comparison
    public static bool operator ==(Vector2D v1, Vector2D v2) {
        if (ReferenceEquals(v1, v2)) return true;
        if (v1 is null || v2 is null) return false;
        return Math.Abs(v1.X - v2.X) < 0.0001 && Math.Abs(v1.Y - v2.Y) < 0.0001;
    }
    
    // Overload the != operator (required when overloading ==)
    public static bool operator !=(Vector2D v1, Vector2D v2) {
        return !(v1 == v2);
    }
    
    // Override Equals and GetHashCode (recommended when overloading == and !=)
    public override bool Equals(object obj) {
        if (obj is Vector2D other)
            return this == other;
        return false;
    }
    
    public override int GetHashCode() {
        return HashCode.Combine(X, Y);
    }
    
    // Override ToString for better display
    public override string ToString() {
        return $"({X}, {Y})";
    }
}
```

**Syntax**: Operator overloads must be `public static` methods with the operator keyword, followed by the `operator` symbol.  

**Common operators you can overload:**  
- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Comparison: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Unary: `+`, `-`, `!`, `~`, `++`, `--`
- Others: `true`, `false`, implicit/explicit conversions
  
**Important rules:**
- Some operators come in pairs (like `==` and `!=`) - if you overload one, you should overload both
- When overloading `==` and `!=`, you should also override `Equals()` and `GetHashCode()`
- Operators like `&&`, `||`, and assignment operators (`+=`, `-=`) cannot be directly overloaded, but they use the overloaded versions of their component operators

**Benefits:**
- Makes code more intuitive and readable
- Allows your custom types to behave like built-in types
- Enables natural mathematical operations on custom objects

---

### Q. What is the difference between **compile-time polymorphism** and **runtime polymorphism**?
The key difference between compile-time and runtime polymorphism lies in **when** the decision about which method to call is made:
- **Compile-time polymorphism** (or static polymorphism) is resolved during compilation. This is typically achieved through method overloading or operator overloading.
- **Runtime polymorphism** (or dynamic polymorphism) is resolved during runtime. This is usually achieved through method overriding, where a base class reference points to a derived class object.  

Aspect | Compile-Time | Runtime
--- | --- | ---
When decided | During compilation | During execution
Performance | Faster (no runtime lookup) | Slightly slower (virtual method table lookup)
Flexibility | Less flexible | More flexible
Method resolution | Based on compile-time type | Based on actual object type
Keywords | Method overloading, operator overloading | `virtual`, `override`, `abstract`, interfaces

Runtime polymorphism is more powerful for creating flexible, extensible code where you don't know the exact types until runtime, while compile-time polymorphism offers better performance when the types are known at compile time.

---

### Q. Can you override static methods in C#? Why or why not?
No, you cannot override static methods in C#. Here's why:  

Static methods belong to the class itself, not to instances of the class. They are resolved at compile-time based on the type, not at runtime based on the object's actual type. Method overriding relies on runtime polymorphism, which requires instance methods and a virtual table (vtable) to resolve the method call dynamically. Since static methods are not associated with instances, they don't participate in this mechanism.  

However, you can **hide** a static method in a derived class using the `new` keyword. This is not overriding but shadowing, meaning the derived class provides a new implementation that hides the base class's static method. The method called depends on the compile-time type of the reference, not the runtime type.  

```csharp
public class Base {
    public static void Method() { }
}

public class Derived : Base {
    // This won't compile with 'override'
    // public override static void Method() { } // Error!
    
    // This creates a completely separate method (method hiding)
    public static void Method() { } // Legal but not overriding
}
```
---
