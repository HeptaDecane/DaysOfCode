# Polymorphism
Polymorphism is a core concept in object-oriented programming that allows objects of different types to be treated as objects of a common super type, enabling the same method or operation to behave differently based on the object calling it. Polymorphism in C# is primarily achieved through **method overriding** (runtime polymorphism) and **method overloading** (compile-time polymorphism).

## ðŸ”‘ Types of Polymorphism in C#

1. **Compile-time Polymorphism (Static Binding / Early Binding)**
   - Achieved using **method overloading** and **operator overloading**.
   - Which method to call is decided at **compile time**.
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b;
        public int Add(int a, int b, int c) => a + b + c;
    }

    class Program {
        static void Main() {
            Calculator calc = new Calculator();
            Console.WriteLine(calc.Add(2, 3));         // Calls int version
            Console.WriteLine(calc.Add(2.5, 3.5));     // Calls double version
            Console.WriteLine(calc.Add(1, 2, 3));      // Calls 3-parameter version
        }
    }
    ```
2. **Runtime Polymorphism (Dynamic Binding / Late Binding)**
    - Achieved using **method overriding** (with inheritance and `virtual`/`override` keywords).
    - Which method to call is decided at **runtime**, depending on the object type.
    ```csharp
    class Animal {
        public virtual void Speak() {
            Console.WriteLine("The animal makes a sound.");
        }
    }

    class Dog : Animal {
        public override void Speak() {
            Console.WriteLine("The dog barks.");
        }
    }

    class Cat : Animal {
        public override void Speak() {
            Console.WriteLine("The cat meows.");
        }
    }

    class Program {
        static void Main() {
            Animal a1 = new Dog();
            Animal a2 = new Cat();

            a1.Speak(); // Output: The dog barks.
            a2.Speak(); // Output: The cat meows.
        }
    }
    ```

## ðŸŽ¯ Goals of Polymorphism
- **Code Reusability**: 
    - Write general code once, and let derived classes provide their specific behavior.
    - Example: A `List<T>` works with `int`, `string`, `Car`, or any object type, because of polymorphism.

- **Extensibility / Flexibility**:
    - New classes can be added without changing existing code, as long as they implement the same interface or override the base methods.
    - Example: Adding a new `Bird` class with `Speak()` doesnâ€™t require changing the existing `Animal` code.

- **Loose Coupling**:
    - Code depends on **abstractions (interfaces or base classes)** instead of concrete implementations.
    - Makes systems less fragile and easier to modify.

- **Improved Readability**:
    - You can call the same method on different objects, and the behavior is appropriate without extra conditionals (`if` / `switch`).
    - Example: Instead of checking `if (animal is Dog)` everywhere, just call `animal.Speak()` and let polymorphism handle it.

- **Supports "Program to an Interface" Principle**:
    - Allows you to use dependency injection and design patterns effectively (like Strategy, Factory, Adapter).

In short, the goal of polymorphism is to **treat different objects uniformly while letting each object define its own specific behavior**.


## âœ… Ways C# supports polymorphism:

### 1. Compile-time Polymorphism
Achieved at compile time.
- **Method Overloading**: Same method name but different parameter signatures.
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b; // overload
    }
    ```

- **Operator Overloading**: Redefine operators for user-defined types.
    ```csharp
    class Complex {
        public int Real { get; set; }
        public int Imaginary { get; set; }

        public static Complex operator +(Complex c1, Complex c2) 
            => new Complex { Real = c1.Real + c2.Real, Imaginary = c1.Imaginary + c2.Imaginary };
    }
    ```

### 2. Runtime Polymorphism
Achieved at runtime, mainly with **inheritance** and **interfaces**.
- **Method Overriding with `virtual` and `override`**
    ```csharp
    class Animal {
        public virtual void Speak() => Console.WriteLine("Animal speaks");
    }

    class Dog : Animal {
        public override void Speak() => Console.WriteLine("Dog barks");
    }
    ```

- **Abstract Classes and Methods**: Force derived classes to provide implementation.
    ```csharp
    abstract class Shape {
        public abstract void Draw();
    }

    class Circle : Shape {
        public override void Draw() => Console.WriteLine("Drawing Circle");
    }
    ```

- **Interfaces**: Multiple classes implement the same contract. 
    ```csharp
    interface IPayment {
        void Pay(decimal amount);
    }

    class CreditCardPayment : IPayment {
        public void Pay(decimal amount) => Console.WriteLine($"Paid {amount} using Credit Card");
    }
    ```

- **Method Hiding**: Using the `new` keyword. Not true overriding, but allows redefining a method in a derived class.
    ```csharp
    class Base {
        public void Show() => Console.WriteLine("Base Show");
    }

    class Derived : Base {
        public new void Show() => Console.WriteLine("Derived Show");
    }
    ```

### 3. Other Forms of Polymorphism in C#
- **Generics (Parametric Polymorphism)**: Write code that works with any data type.
    ```csharp
    class GenericList<T> {
        private List<T> _items = new List<T>();

        public void Add(T item) => _items.Add(item);
        public T Get(int index) => _items[index];
    }
    ```

- **Delegates and Events**: Allow methods to be passed as parameters, enabling callback mechanisms.
    ```csharp
    public delegate void Notify(string message);

    class Process {
        public Notify OnProcessCompleted;

        public void StartProcess() {
            // Process logic here
            OnProcessCompleted?.Invoke("Process Completed!");
        }
    }
    ```

- **Dynamic Keyword (Dynamic Binding)**: Method resolution happens at runtime, bypassing compile-time checks.
    ```csharp
    dynamic obj = "Hello, World!";
    Console.WriteLine(obj.Length); // Resolved at runtime
    ```

## Interview Questions

### Q. What is polymorphism in C#, and why is it important?
Polymorphism in C# is a fundamental object-oriented programming concept that allows objects of different types to be treated as instances of the same base type, while maintaining their specific behaviors.  

There are several types of polymorphism in C#:    
- **Runtime Polymorphism (Method Overriding)**: This is achieved through inheritance and virtual methods. A base class defines a virtual method, and derived classes can override it with their own implementations.
- **Interface Polymorphism**: Different classes can implement the same interface, allowing them to be used interchangeably.
- **Compile-time Polymorphism (Method Overloading)**: This is achieved by defining multiple methods with the same name but different parameter lists within the same class.  


**Why Polymorphism is Important**  
Polymorphism is essential for writing flexible, maintainable, and scalable object-oriented code. It enables you to design systems that can grow and adapt to new requirements with minimal changes to existing code.  
- **Flexibility and Extensibility**: You can write code that works with **base types or interfaces**, making it easy to add new derived types without changing existing code. This follows the Open/Closed Principle - open for extension, closed for modification.  
- **Code Reusability**: Instead of writing separate methods for each specific type, you can write generic code that works with multiple types.  
- **Maintainability**: Changes to specific implementations don't affect the code that uses them polymorphically. This reduces coupling between components and makes systems easier to maintain.  
- **Abstraction**: Polymorphism allows you to work with objects at a higher level of abstraction, focusing on what they can do rather than their specific implementation details. This makes code more readable and conceptually cleaner.  
- **Design Patterns**: Many important design patterns rely heavily on polymorphism, such as Strategy, Factory, and Template Method patterns. These patterns help solve common programming problems elegantly.  

---

### Q. What are the two types of polymorphism in C#?
**1. Compile-time Polymorphism (Static Polymorphism)**  
This is resolved at compile time and includes:  
- **Method Overloading**: Multiple methods with the same name but different parameters (different number, types, or order of parameters)
- **Operator Overloading**: Defining custom behavior for operators like +, -, ==, etc. for user-defined types

**2. Runtime Polymorphism (Dynamic Polymorphism)**
This is resolved at runtime and is achieved through:  
- **Method Overriding**: Using virtual methods in base classes and override methods in derived classes
- **Interface Implementation**: Implementing interface methods in different classes  

Runtime polymorphism allows you to call the same method on different objects and get different behaviors based on the actual object type at runtime, which is determined through method dispatch using the virtual method table (vtable).

---

### Q. What is the difference between method overloading and method overriding?
**Method Overloading:**  
- **Definition**: Method overloading allows a class to have multiple methods with the **same name** but different **parameter lists** (different number, types, or order of parameters).
- **Purpose**: It provides flexibility to call the same method name with different inputs, improving code readability and reusability.
- **Key Characteristics**:
  - Occurs within the **same class**.
  - Methods must differ in their **signature** (number, type, or order of parameters).
  - The **return type** alone cannot differentiate overloaded methods.
  - It is resolved at **compile time** (static polymorphism).
  - Example:
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b; // Overloaded method
        public int Add(int a, int b, int c) => a + b + c; // Overloaded method
    }
    ```

**Method Overriding:**
- **Definition**: Method overriding allows a **derived class** to provide a specific implementation of a method that is already defined in its **base class**.
- **Purpose**: It enables runtime polymorphism, allowing a derived class to modify or extend the behavior of a base class method.
- **Key Characteristics:**
	- Occurs between a **base class** and a **derived class**.
	- The method in the derived class must have the **same name, parameters, and return type** as the method in the base class.
	- The base class method must be marked with the `virtual` or `abstract` keyword, and the derived class method must use the `override` keyword.
	- It is resolved at **runtime** (dynamic polymorphism).
	- Example:
		```csharp
		class Shape {
			public virtual void Draw() => Console.WriteLine("Drawing a shape");
		}

		class Circle : Shape {
			public override void Draw() => Console.WriteLine("Drawing a circle");
		}
		```

**Key Differences:**  
Aspect | Method Overloading | Method Overriding
--- | --- | ---
Definition | Same method name, different parameter lists. | Same method name, same parameters, different implementation.
Location | Within the same class. | Between base and derived classes.
Polymorphism Type | Compile-time (static). | Runtime (dynamic).
Method Signature | Must differ (parameters). | Must be identical (name, parameters, return type).
Keywords | No special keywords required. | `virtual`/`abstract` in base class, `override` in derived class.
Purpose | Flexibility in method calls with different inputs. | Customize or extend base class behavior.

---

### Q. What is the purpose of the `virtual` and `override` keywords in C#?
**`virtual` Keyword:**  
The `virtual` keyword is used in a base class to indicate that a method can be overridden by derived classes. It allows you to provide a default implementation while giving subclasses the option to provide their own specific implementation.
```csharp
public class Shape {
	public virtual void Draw() {
		Console.WriteLine("Drawing a shape");
	}
}
```

**`override` Keyword:**  
The `override` keyword is used in a derived class to provide a new implementation of a virtual method from the base class. The method signature must exactly match the base class method.
```csharp
public class Circle : Shape {
	public override void Draw() {
		Console.WriteLine("Drawing a circle");
	}
}

public class Square : Shape {
	public override void Draw() {
		Console.WriteLine("Drawing a square");
	}
}
```

**Key Points:**  
- **Polymorphism**: When you have a base class reference pointing to a derived class object, calling a virtual method will execute the overridden version in the derived class, not the base class version.
	```csharp
	Shape circle = new Circle();
	circle.Draw(); // Output: Drawing a circle
	```

- **Method Chaining**: You can call the base class implementation from an overridden method using base.MethodName():
	```csharp
	public class Circle : Shape {
		public override void Draw() {
			base.Draw();	// Call base implementation
			Console.WriteLine("Drawing a circle");
		}
	}
	```
---

### Q. Can you overload methods in C# only by changing the return type? Why or why not?
No, you cannot overload methods in C# by changing only the return type. Method overloading in C# is determined by the method's **signature**, which includes:
1. Method name
2. Number of parameters
3. Type of parameters
4. Order of parameters
The return type is **not** part of the method signature for overloading purposes.

**The Problem with Return-Type-Only Overloading**  
Consider this hypothetical scenario if C# allowed return-type-only overloading:
```csharp
public int Calculate(int x, int y) { return x + y; }
public string Calculate(int x, int y) { return (x + y).ToString(); }
```
Now imagine calling this method:
```csharp
var result = Calculate(5, 10); // Which method should be called?
```
The compiler cannot determine which overload to use because the call site doesn't specify what type the result should be.  
This creates ambiguity that would make the code unpredictable and error-prone.  

**What Actually Works for Overloading**  
```csharp
public int Calculate(int x, int y) { return x + y; }
public int Calculate(double x, double y) { return (int)(x + y); }
public int Calculate(int x, int y, int z) { return x + y + z; }
public int Calculate(string operation, int x, int y)  { 
    return operation == "add" ? x + y : x - y; 
}
```

**Alternative Approaches**  
If you need different return types for similar operations, consider:  
- **Different method names**: `CalculateSum()` and `CalculateDescription()`
- **Generic methods**: Use type parameters to handle different return types
- **Out parameters**: Return multiple values or use tuple returns

---

### Q. What is operator overloading? Give an example.
Operator overloading is a feature that allows you to define custom behavior for operators (like +, -, *, ==, etc.) when they are used with user-defined types such as classes or structs. Instead of operators only working with built-in types like int or string, you can make them work meaningfully with your custom objects.

In C#, you implement operator overloading by defining special static methods in your class using the `operator` keyword.  
Here's a practical example with a `Vector2D` class:
```csharp
public class Vector2D {
    public double X { get; set; }
    public double Y { get; set; }
    
    public Vector2D(double x, double y) {
        X = x;
        Y = y;
    }
    
    // Overload the + operator for vector addition
    public static Vector2D operator +(Vector2D v1, Vector2D v2) {
        return new Vector2D(v1.X + v2.X, v1.Y + v2.Y);
    }
    
    // Overload the - operator for vector subtraction
    public static Vector2D operator -(Vector2D v1, Vector2D v2) {
        return new Vector2D(v1.X - v2.X, v1.Y - v2.Y);
    }
    
    // Overload the * operator for scalar multiplication
    public static Vector2D operator *(Vector2D v, double scalar) {
        return new Vector2D(v.X * scalar, v.Y * scalar);
    }
    
    // Overload the * operator for scalar multiplication (commutative)
    public static Vector2D operator *(double scalar, Vector2D v) {
        return new Vector2D(v.X * scalar, v.Y * scalar);
    }
    
    // Overload the == operator for equality comparison
    public static bool operator ==(Vector2D v1, Vector2D v2) {
        if (ReferenceEquals(v1, v2)) return true;
        if (v1 is null || v2 is null) return false;
        return Math.Abs(v1.X - v2.X) < 0.0001 && Math.Abs(v1.Y - v2.Y) < 0.0001;
    }
    
    // Overload the != operator (required when overloading ==)
    public static bool operator !=(Vector2D v1, Vector2D v2) {
        return !(v1 == v2);
    }
    
    // Override Equals and GetHashCode (recommended when overloading == and !=)
    public override bool Equals(object obj) {
        if (obj is Vector2D other)
            return this == other;
        return false;
    }
    
    public override int GetHashCode() {
        return HashCode.Combine(X, Y);
    }
    
    // Override ToString for better display
    public override string ToString() {
        return $"({X}, {Y})";
    }
}
```

**Syntax**: Operator overloads must be `public static` methods with the operator keyword, followed by the `operator` symbol.  

**Common operators you can overload:**  
- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Comparison: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Unary: `+`, `-`, `!`, `~`, `++`, `--`
- Others: `true`, `false`, implicit/explicit conversions
  
**Important rules:**
- Some operators come in pairs (like `==` and `!=`) - if you overload one, you should overload both
- When overloading `==` and `!=`, you should also override `Equals()` and `GetHashCode()`
- Operators like `&&`, `||`, and assignment operators (`+=`, `-=`) cannot be directly overloaded, but they use the overloaded versions of their component operators

**Benefits:**
- Makes code more intuitive and readable
- Allows your custom types to behave like built-in types
- Enables natural mathematical operations on custom objects

---

### Q. What is the difference between **compile-time polymorphism** and **runtime polymorphism**?
The key difference between compile-time and runtime polymorphism lies in **when** the decision about which method to call is made:
- **Compile-time polymorphism** (or static polymorphism) is resolved during compilation. This is typically achieved through method overloading or operator overloading.
- **Runtime polymorphism** (or dynamic polymorphism) is resolved during runtime. This is usually achieved through method overriding, where a base class reference points to a derived class object.  

Aspect | Compile-Time | Runtime
--- | --- | ---
When decided | During compilation | During execution
Performance | Faster (no runtime lookup) | Slightly slower (virtual method table lookup)
Flexibility | Less flexible | More flexible
Method resolution | Based on compile-time type | Based on actual object type
Keywords | Method overloading, operator overloading | `virtual`, `override`, `abstract`, interfaces

Runtime polymorphism is more powerful for creating flexible, extensible code where you don't know the exact types until runtime, while compile-time polymorphism offers better performance when the types are known at compile time.

---

### Q. Can you override static methods in C#? Why or why not?
No, you cannot override static methods in C#. Here's why:  

Static methods belong to the class itself, not to instances of the class. They are resolved at compile-time based on the type, not at runtime based on the object's actual type. Method overriding relies on runtime polymorphism, which requires instance methods and a virtual table (vtable) to resolve the method call dynamically. Since static methods are not associated with instances, they don't participate in this mechanism.  

However, you can **hide** a static method in a derived class using the `new` keyword. This is not overriding but shadowing, meaning the derived class provides a new implementation that hides the base class's static method. The method called depends on the compile-time type of the reference, not the runtime type.  

```csharp
public class Base {
    public static void Method() { }
}

public class Derived : Base {
    // This won't compile with 'override'
    // public override static void Method() { } // Error!
    
    // This creates a completely separate method (method hiding)
    public static void Method() { } // Legal but not overriding
}
```
---

### Q. Whatâ€™s the difference between **method overriding** and **method hiding** (`new` keyword)?  

**Method Overriding**
- **Definition**: Method overriding occurs when a derived class provides a specific implementation for a **virtual** or **abstract** method defined in a base class. The overridden method in the derived class replaces the base class method when called on an instance of the derived class, even if the instance is referenced as the base class type.
- **Keywords**: Requires the base class method to be marked with `virtual` or `abstract`, and the derived class method to be marked with `override`.
- **Polymorphism**: Enables **runtime polymorphism**, where the method to be executed is determined at runtime based on the actual type of the object.
- **Behavior**: When a method is overridden, calling the method on a base class reference that points to a derived class object invokes the derived class's implementation.
- **Example**:
    ```csharp
    public class Base {
        public virtual void Show() {
            Console.WriteLine("Base Show");
        }
    }

    public class Derived : Base {
        public override void Show() {
            Console.WriteLine("Derived Show");
        }
    }

    Base obj = new Derived();
    obj.Show(); // Output: "Derived Show"
    ```

**Method Hiding**
- **Definition**: Method hiding occurs when a derived class defines a method with the same name as a method in the base class, but it does **not** override the base class method. Instead, it hides the base class method, creating a new method that is unrelated to the base class method in terms of polymorphism.
- **Keyword**: Uses the `new` keyword explicitly to indicate that the method in the derived class is intentionally hiding the base class method. If `new` is omitted, the compiler may issue a warning but still hide the method.
- **Polymorphism**: Does **not** enable runtime polymorphism. The method called depends on the reference type, not the actual object type.
- **Behavior**: When a method is hidden, calling the method on a base class reference invokes the base class method, while calling it on a derived class reference invokes the derived class method.
- **Example**:
    ```csharp
        public class Base {
            public void Show() {
                Console.WriteLine("Base Show");
            }
        }

        public class Derived : Base {
            public new void Show() { // Hides the base class method
                Console.WriteLine("Derived Show");
            }
        }

        Base obj1 = new Derived();
        obj1.Show(); // Output: "Base Show" (base class method)

        Derived obj2 = new Derived();
        obj2.Show(); // Output: "Derived Show" (derived class method)
    ```

**When to Use**  
**Method Overriding**: Use when you want polymorphic behavior, where the derived class provides a specialized implementation of a method that the base class defines as part of its contract. Common in scenarios where you want subclasses to customize behavior (e.g., a `Shape` class with a `Draw` method overridden by `Circle` or `Square`).  
**Method Hiding**: Use when you want to define a method in the derived class that happens to have the same name as a base class method but is not intended to participate in the same polymorphic behavior. This is less common and should be used cautiously to avoid confusion.

---

### Q. What happens if you have two methods with the same signature in base and derived classes, but donâ€™t use `virtual`, `override`, or `new`?  
When you have two methods with the same signature in base and derived classes without using `virtual`, `override`, or `new` keywords, you get **method hiding** (also called method shadowing).
```csharp
class Base {
    public void DoSomething() {
        Console.WriteLine("Base implementation");
    }
}

class Derived : Base {
    public void DoSomething() { // This hides the base method
        Console.WriteLine("Derived implementation");
    }
}

Base baseRef = new Derived();
baseRef.DoSomething(); // Output: "Base implementation"

Derived derivedRef = new Derived();
derivedRef.DoSomething(); // Output: "Derived implementation"
```

**Behavior:**  
- **Compile-time warning**: The compiler will generate a warning like "Member hides inherited member. Use the new keyword if hiding was intended."
- **No polymorphism**: Unlike virtual methods, there's no dynamic dispatch. The method called is determined by the compile-time type of the reference, not the runtime type of the object.

---

### Q. Can constructors be overridden in C#? Why?  
No, constructors cannot be overridden in C#. Here's why:  
- **Constructors are not inherited**: Unlike regular methods, constructors are not inherited by derived classes, and without inheritance, there's nothing to override. Each class is responsible for its own initialization, and derived classes must call the base class constructor explicitly if needed.
- **Purpose of constructors**: Constructors are specifically responsible for initializing the particular class they belong to, and each class needs its own initialization logic. Virtual methods are designed for polymorphic behavior where derived classes can change the implementation.
- **No virtual/override keywords allowed**: The compiler doesn't allow you to mark constructors as `virtual`, `override`, or `abstract`. This is by design to prevent the confusion that would arise from constructor polymorphism.  

**What You Can Do Instead:**  
- Use constructor chaining with the `base` keyword to call a base class constructor.
    ```csharp
    public class BaseClass {
        public BaseClass(int value) {
            // Base initialization
        }
    }

    public class DerivedClass : BaseClass  {
        public DerivedClass(int value) : base(value) {  // Call base constructor
            // Additional derived class initialization
        }
    }
    ```
- Use factory methods or static methods to create instances of classes.
- Implement the **Builder** pattern to construct complex objects step by step.
- Use composition over inheritance to achieve code reuse without relying on constructor overriding.
  
---

### Q. How does polymorphism improve code **reusability** and **maintainability**?  
**Code Reusability**  
- **Shared Interfaces or Superclasses:**  
    Polymorphism allows methods to operate on objects of a common interface or superclass, so you can write code that works with multiple types without duplicating logic.  
    **Example**: A method that processes a `Shape` interface can handle `Circle`, `Rectangle`, or any new shape class implementing `Shape`, without rewriting the method. 

- **Generic Code:**  
    By using polymorphic types (e.g., abstract classes or interfaces), you can write generic algorithms or functions that apply to a family of related classes.  
    **Example**: A `List` interface allows the same code to work with `ArrayList`, `LinkedList`, or custom list implementations.

- **Extensibility:**  
    New classes can be added that conform to the same interface or inherit from the same superclass, and existing code can use them without modification.  
    **Example**: Adding a new `PaymentMethod` (e.g., `CryptoPayment`) to a system that processes `CreditCard` and `PayPal` payments requires only implementing the `PaymentMethod` interface.  

**Code Maintainability**  
- **Centralized Logic:**  
    Polymorphism reduces code duplication by centralizing shared behavior in superclasses or interfaces, making it easier to update logic in one place.  
    **Example**: Changing how a `draw()` method works for all shapes can be done in the `Shape` superclass or interface, rather than in each shape class.  

- **Reduced Coupling:**  
    Code depends on abstractions (interfaces or superclasses) rather than concrete implementations, making it easier to swap or modify implementations without affecting the rest of the system.  
    **Example**: A `DatabaseConnection` interface allows switching between `MySQLConnection` and `PostgreSQLConnection` without changing the code that uses the connection.  

- **Easier Debugging and Testing:**  
    Polymorphic code is often more modular, as it relies on well-defined interfaces or inheritance hierarchies. This modularity simplifies debugging and testing, as you can focus on individual implementations or mock polymorphic types.  
    **Example**: Unit tests can mock a `Logger` interface to test logging behavior without touching the actual file or console logger.  

**Conclusion**  
Polymorphism enhances **reusability** by enabling generic, reusable code that works with multiple types and supports extensibility. It improves **maintainability** by reducing duplication, decoupling components, and simplifying updates or debugging. By designing systems around abstractions, polymorphism makes code more flexible and easier to manage as requirements evolve.

---

### Q. When would you use **abstract classes** vs **interfaces** to achieve polymorphism?  
**Use abstract classes when:**  
- **Shared Implementation**: You want to provide common functionality (code, fields, or properties) that derived classes can inherit and reuse, while still enforcing certain methods to be overridden.  
   **Example**: A base class `Shape` with a common method `CalculateArea()` and an abstract method `Draw()`.  
- **Related Classes**: The classes share an "is-a" relationship (e.g., `Triangle` is a `Shape`) and form a natural hierarchy.
- **State Management**: The base class needs to maintain state (fields or properties) shared by derived classes.
- **Versioning Control**: You need control over the class hierarchy, as abstract classes are less flexible for external extensions (e.g., you can add non-abstract methods without breaking derived classes).

**Use interfaces when:**  
- **Contract-Based Design**: You want to define a contract that unrelated classes can implement, focusing on "can-do" relationships (e.g., `IFlyable` for anything that can fly, like a `Bird` or `Airplane`).
- **Multiple Implementations**: A class needs to implement multiple behaviors, as C# allows multiple interface implementations.
- **Loose Coupling**: You want flexibility and decoupling, allowing classes to implement the interface without being tied to a specific hierarchy.
- **Cross-Domain Abstraction**: You need to enforce behavior across unrelated types (e.g., `IComparable` for sorting different objects).

**Practical Example**  
Suppose you're building a system for different payment methods:  

- Use an **abstract class** `Payment` if all payment methods share common logic, like `ProcessTransaction()`, and have shared state, like `Amount`.
    ```csharp
    abstract class Payment {
        protected decimal Amount { get; set; }
        public void ProcessTransaction() => Console.WriteLine("Processing...");
        public abstract void Validate();
    }

    class CreditCardPayment : Payment {
        public override void Validate() => Console.WriteLine("Validating card.");
    }
    ```

- Use an interface `IPaymentMethod` if you only need to enforce that all payment methods can `Pay()`, regardless of their implementation.
    ```csharp
    interface IPaymentMethod {
        void Pay();
    }

    class PayPal : IPaymentMethod {
        public void Pay() => Console.WriteLine("Paying via PayPal.");
    }

    class Crypto : IPaymentMethod {
        public void Pay() => Console.WriteLine("Paying via Crypto.");
    }
    ```
---

### Q. How does polymorphism support the **Open/Closed Principle (OCP)** in SOLID design?

Polymorphism is one of the key mechanisms that enables the Open/Closed Principle, which states that software entities should be open for extension but closed for modification. Here's how they work together:  
**Closed for Modification**: The existing code that uses polymorphic interfaces doesn't need to change when new implementations are added. The client code works with abstract types (interfaces or base classes) rather than concrete implementations.  
**Open for Extension**: New functionality can be added by creating new classes that implement existing interfaces or inherit from base classes, without touching the original code.  

**Practical Example**  
Consider a payment processing system:  
```csharp
// Original interface - remains unchanged
interface PaymentProcessor {
    void processPayment(double amount);
}

// Original implementation
class CreditCardProcessor : PaymentProcessor {
    public void processPayment(double amount) {
        // Credit card logic
    }
}

// Client code - closed for modification
class OrderService {
    private PaymentProcessor processor;
    
    public OrderService(PaymentProcessor processor) {
        this.processor = processor;
    }
    
    public void completeOrder(double amount) {
        processor.processPayment(amount); // Polymorphic call
    }
}
```

Now, when you need to add PayPal support:
```csharp
// Extension - new implementation
class PayPalProcessor : PaymentProcessor {
    public void processPayment(double amount) {
        // PayPal-specific logic
    }
}
```
The `OrderService` class never needs modification - it can work with any `PaymentProcessor` implementation through polymorphism.  

**Without polymorphism**: adding new payment methods would require modifying the client code with conditional logic:
```csharp
// Violates OCP - requires modification for each new type
if (paymentType.Equals("creditcard")) {
    // credit card logic
} else if (paymentType.Equals("paypal")) {
    // paypal logic
} // More modifications needed for each new type
```
---

### Q. Explain **parametric polymorphism** in C# with generics.
Parametric polymorphism in C# is a form of polymorphism that allows types to be parameterized, enabling functions or classes to work with different data types without sacrificing type safety. This is primarily achieved through **generics**, introduced in C# 2.0, which allow developers to define classes, interfaces, methods, or delegates with placeholder types that are specified when the code is used.  

**Generic Classes**  
A generic class can work with any data type specified at instantiation.
```csharp
public class GenericList<T> {
    private T[] items = new T[10];
    private int count = 0;

    public void Add(T item) {
        if (count < items.Length)
            items[count++] = item;
    }

    public T Get(int index) {
        return items[index];
    }
}

// Usage
GenericList<int> intList = new GenericList<int>();
intList.Add(42); // Works with int
Console.WriteLine(intList.Get(0)); // Output: 42

GenericList<string> stringList = new GenericList<string>();
stringList.Add("Hello"); // Works with string
Console.WriteLine(stringList.Get(0)); // Output: Hello
```

**Generic Methods**  
Methods can also be generic, allowing them to operate on different types.
```csharp
public class Utility {
    public static void Swap<T>(ref T a, ref T b) {
        T temp = a;
        a = b;
        b = temp;
    }
}

// Usage
int x = 5, y = 10;
Utility.Swap(ref x, ref y);
Console.WriteLine($"x: {x}, y: {y}"); // Output: x: 10, y: 5

string s1 = "Hello", s2 = "World";
Utility.Swap(ref s1, ref s2);
Console.WriteLine($"s1: {s1}, s2: {s2}"); // Output: s1: World, s2: Hello
```

**Constraints**  
You can restrict the types that can be used with generics using constraints, ensuring that the type parameter meets specific requirements.
```csharp
public class GenericComparer<T> where T : IComparable<T> {
    public T Max(T a, T b) {
        return a.CompareTo(b) > 0 ? a : b;
    }
}

// Usage
GenericComparer<int> comparer = new GenericComparer<int>();
Console.WriteLine(comparer.Max(5, 10)); // Output: 10
```
The `where T : IComparable<T>` constraint ensures that `T` implements the `IComparable<T>` interface, allowing the use of `CompareTo`.  

Common constraints include:
- `where T : class` (reference type)
- `where T : struct` (value type)
- `where T : new()` (must have a parameterless constructor)
- `where T : <interface>` (must implement a specific interface)
- `where T : <base class>` (must derive from a specific base class)

**Generic Interfaces**  
Interfaces can also be generic, allowing flexible and type-safe contracts.
```csharp
public interface IRepository<T> {
    void Add(T item);
    T Get(int id);
}

public class UserRepository : IRepository<string> {
    public void Add(string item) { /* Implementation */ }
    public string Get(int id) { return $"User {id}"; }
}
```

**Generic Delegates**  
Delegates can be generic, enabling type-safe function pointers.
```csharp
public delegate T Transformer<T>(T input);

public class Utility {
    public static int Square(int x) => x * x;
}

// Usage
Transformer<int> transformer = Square;
Console.WriteLine(transformer(5)); // Output: 25
```

**Benefits of Parametric Polymorphism with Generics**  
- **Type Safety**: Errors are caught at compile-time, e.g., you can't add a `string` to a `GenericList<int>`.
- **Code Reusability**: Write one generic class or method to handle multiple types.
- **Performance**: Avoids boxing/unboxing for value types, unlike non-generic collections.
- **Readability**: Eliminates the need for explicit casting, making code cleaner.

---

### Q. How does the `dynamic` keyword enable polymorphism?
The `dynamic` keyword in C# enables polymorphism by allowing type resolution to occur at runtime rather than compile-time, which provides flexibility in how objects are handled and methods are invoked. This contrasts with static typing, where the type is determined at compile-time, restricting polymorphism to predefined inheritance hierarchies or interfaces. Here's how `dynamic` facilitates polymorphism:  

**Bypassing Static Type Checking:**  
When a variable is declared as `dynamic`, the compiler skips static type checking. Instead, the type and method resolution are deferred to runtime, allowing objects of different types to be assigned to the same `dynamic` variable and have their methods invoked based on their actual runtime type.  
This enables polymorphic behavior because the same variable can reference objects of unrelated types, and the appropriate method is called based on the actual object type at runtime.  

**Flexibility Across Types:**  
Unlike traditional polymorphism, which relies on inheritance (e.g., overriding virtual methods in derived classes) or interfaces, `dynamic` allows polymorphism across types that donâ€™t share a common base class or interface. This is useful when working with objects from dynamic languages, COM objects, or loosely typed data (e.g., JSON).

```csharp
// Traditional polymorphism - requires common base
IShape[] shapes = { new Circle(), new Rectangle() };
foreach (IShape shape in shapes)
    shape.Draw(); // Must be defined in IShape

// Dynamic polymorphism - no common base needed
dynamic[] objects = { new Circle(), new Rectangle(), new Triangle() };
foreach (dynamic obj in objects)
    obj.Draw(); // Resolved at runtime
```

**Trade-offs:**  
- **Performance**: Using `dynamic` incurs a performance cost due to runtime type resolution and reflection, unlike compile-time polymorphism, which is faster.
- **Safety**: Since type checking is deferred to runtime, errors (e.g., calling a nonexistent method) are caught only when the code executes, not at compile-time.
- **Use Cases**: `dynamic` is particularly useful for interop with dynamic languages (e.g., Python, JavaScript), COM objects, or scenarios where type flexibility is needed, such as parsing dynamic JSON or working with loosely typed APIs.

---

### Q. What happens if a derived class declares a method with the same signature as a base class `virtual` method but forgets to use `override`?
If a derived class declares a method with the same signature as a base class `virtual` method but forgets to use the `override` keyword,  
the method becomes a **new method that hides the base class method** rather than overriding it.
```csharp
public class Base {
    public virtual void Show() {
        Console.WriteLine("Base Show");
    }
}

public class Derived : Base {
    // Hides the base class method, does not override
    public void Show() { 
        Console.WriteLine("Derived Show");
    }
}

Base _base = new Derived();
_base.Show(); // Output: "Base Show"

Derived _derived = new Derived();
_derived.Show(); // Output: "Derived Show"
```

---

### Q. How does C# perform **method resolution** when multiple overloads exist?
C# uses a sophisticated method resolution process to determine which overload to call when multiple candidates exist. Here's how it works:   

**1. Candidate Method Collection**: C# first identifies all accessible methods with the correct name in the current scope, including methods from base classes and extension methods.  

**2. Applicable Member Filtering**: Methods are filtered based on whether arguments can be converted to their parameters. This includes:
- Exact matches
- Implicit conversions (e.g., int to double)
- Params array expansion
- Optional parameter consideration

**3. Better Function Member Selection**: C# ranks the remaining candidates using these criteria (in order of preference):  

  - **Conversion Quality Hierarchy**  
    1. Exact match - no conversion needed
    2. Identity conversion - same type
    3. Implicit numeric conversions (int â†’ long â†’ float â†’ double)
    4. Implicit reference conversions (derived â†’ base class)
    5. Boxing conversions (value type â†’ object)
    6. User-defined implicit conversions
    7. Params array conversion (lowest priority)

  - **Specificity Rules**
    - More specific parameter types win - `Method(string s)` beats `Method(object o)` when passed a string
    - Non-generic methods preferred over generic
    - Fewer type parameters preferred in generic methods
    - Methods in derived classes beat base class methods

```csharp
public class Example {
    public void Process(int value) { }           // Method A
    public void Process(long value) { }          // Method B  
    public void Process(object value) { }        // Method C
    public void Process(params int[] values) { } // Method D
}

// Resolution examples:
Process(42);        // Calls A (exact match)
Process(42L);       // Calls B (exact match)
Process("text");    // Calls C (string â†’ object)
Process(1, 2, 3);   // Calls D (params expansion)
```

**Ambiguity and Compile Errors**  
If the compiler cannot determine a single "best" method after applying all rules, it generates a compile-time error for ambiguous call. This commonly happens with:
- Multiple equally-good implicit conversions
- Generic method constraints that don't clearly distinguish candidates
- Extension methods with similar signatures

---

### Q. Can polymorphism be achieved without inheritance in C#? Explain with examples.
Yes, polymorphism can definitely be achieved without inheritance in C#. There are several ways to accomplish this, with **interfaces** being the most common and powerful approach. Unlike inheritance-based polymorphism (where a base class defines common behavior), these approaches rely on shared behavior (via interfaces or method signatures) rather than a shared class hierarchy.

**Interface-based Polymorphism**  
```csharp
// Interface defining a contract
public interface IDrawable {
    void Draw();
    double GetArea();
}

// Different classes implementing the same interface
public class Circle : IDrawable {
    private double radius;
    public Circle(double radius) { this.radius = radius; }
    public void Draw() { Console.WriteLine($"Drawing a circle with radius {radius}"); }
    public double GetArea() => Math.PI * radius * radius;
}

public class Rectangle : IDrawable {
    private double width, height;
    public Rectangle(double width, double height) { this.width = width; this.height = height; }
    public void Draw() { Console.WriteLine($"Drawing a rectangle {width}x{height}"); }
    public double GetArea() => width * height;
}

// Using polymorphism with interface references
IDrawable[] shapes = { new Circle(5), new Rectangle(4, 6) };
foreach (var shape in shapes) {
    shape.Draw(); // Calls the appropriate Draw method
    Console.WriteLine($"Area: {shape.GetArea()}");
}
```

**Delegate-based Polymorphism**  
```csharp
// Define a delegate type
public delegate void ProcessOperation(int value);

public class MathOperations {
    public static void Double(int value) { Console.WriteLine($"Double: {value * 2}"); }
    public static void Square(int value) { Console.WriteLine($"Square: {value * value}"); }
    public static void Cube(int value) { Console.WriteLine($"Cube: {value * value * value}"); }
}

public class StringOperations {
    public static void Indent(int spaces) { Console.WriteLine(new string(' ', spaces)); }
}

// Array of different operations with same signature
ProcessOperation[] operations = {
    MathOperations.Double, MathOperations.Square, 
    MathOperations.Cube, StringOperations.Indent
};

// Polymorphic execution - same call, different behaviors
int value = 7;
foreach (ProcessOperation operation in operations) operation(value);


// Using Func delegate
Func<int, int>[] mathFunctions = {
    x => x * 2,           // Lambda: double
    x => x * x,           // Lambda: square
    x => x * x * x,       // Lambda: cube
    x => x + 10           // Lambda: add 10
};

foreach (var func in mathFunctions) Console.WriteLine(func(value)); 
``` 

**Generic-based Polymorphism**
```csharp
// Generic container with polymorphic behavior
public interface IContainer<T> {
    void Add(T item);
    T? Get();
    bool IsEmpty();
}

public class Stack<T> : IContainer<T> {
    private List<T> items = new List<T>();
    public bool IsEmpty() => items.Count == 0;
    public void Add(T item) { items.Add(item); }
    public T? Get() {
        if (IsEmpty()) return null;
        T item = items[items.Count - 1];
        items.RemoveAt(items.Count - 1);
        return item;
    }
}

public class Queue<T> : IContainer<T> {
    private List<T> items = new List<T>();
    public bool IsEmpty() => items.Count == 0;
    public void Add(T item) { items.Add(item); }
    public T? Get() {
        if (IsEmpty()) return null;
        T item = items[0];
        items.RemoveAt(0);
        return item;
    }
}

/*
- Container polymorphism
- Same interface, different types of containers
*/
```

**Dynamic Polymorphism**  
C#â€™s `dynamic` type allows for duck typing, where objects are treated based on their behavior (methods/properties) rather than their type. This can achieve polymorphism without inheritance.
```csharp
// Class 1: Circle
public class Circle{
    private double radius = 5.0;
    public double CalculateArea() => Math.PI * radius * radius;
    public void Draw() => Console.WriteLine("Drawing Circle");
}

// Class 2: Rectangle (no inheritance relationship with Circle)
public class Rectangle{
    private double width = 4.0, height = 6.0;
    public double CalculateArea() => width * height;
    public void Draw() => Console.WriteLine("Drawing Rectangle");
}

// Polymorphic behavior: call methods dynamically, Resolved at runtime
dynamic[] shapes = { new Circle(), new Rectangle() };
foreach (var shape in shapes) {
    shape.Draw();
    Console.WriteLine($"Area of {shape.GetType().Name}: {shape.CalculateArea()}");
}
```
---

### Q. How would you design a **plugin system** using polymorphism so that new modules can be added without modifying existing code?  
**1. Define a Common Contract (Interface / Abstract Class):**  
All plugins should follow a contract. In C#, thatâ€™s usually an `interface` or an `abstract class`.
```csharp
public interface IPlugin {
    string Name { get; }
    void Execute();
}
```
This defines **what a plugin is**. The main application only knows this interface, not any concrete implementation.  

**2. Implement Plugins Using Polymorphism:**  
```csharp
public class PdfExportPlugin : IPlugin {
    public string Name => "PDF Exporter";
    public void Execute() => Console.WriteLine("Exporting to PDF...");
}

public class EmailNotificationPlugin : IPlugin {
    public string Name => "Email Notifier";
    public void Execute() => Console.WriteLine("Sending email notification...");
}
```

**3. Load Plugins Dynamically (Extensibility):**  
To avoid modifying existing code, plugins should be loaded dynamically.  
Ways to do this in C#: 
- **Reflection**: Load assemblies (`.dll` files) from a folder.
- **Dependency Injection**: Register new implementations without touching core code.
- **MEF (Managed Extensibility Framework)**: Built-in framework for plugin discovery.

Example with Reflection:
```csharp
public static class PluginLoader {
    public static List<IPlugin> LoadPlugins(string path) {
        var plugins = new List<IPlugin>();

        foreach (var dll in Directory.GetFiles(path, "*.dll")) {
            var assembly = Assembly.LoadFrom(dll);
            var types = assembly.GetTypes().Where(t => typeof(IPlugin).IsAssignableFrom(t) && !t.IsInterface);

            foreach (var type in types) {
                var plugin = Activator.CreateInstance(type) as IPlugin;
                plugins.Add(plugin);
            }
        }
        return plugins;
    }
}
```

**4. Client Code Uses Only the Abstraction:**  
The client app doesnâ€™t care **what plugins exist**; it just runs them.
```csharp
class Program {
    static void Main(string[] args) {
        var plugins = PluginLoader.LoadPlugins("Plugins"); // Load from Plugins folder

        foreach (var plugin in plugins) {
            Console.WriteLine($"Executing plugin: {plugin.Name}");
            plugin.Execute(); // Polymorphic call
        }
    }
}
```

**Benefits:**  
- **Open/Closed Principle (OCP)**: The system is **open for extension** (new plugins) but **closed for modification** (no need to change core code).
- **Polymorphism**: Core code uses `IPlugin`, letting different implementations run without knowing details.
- **Separation of Concerns**: Core app focuses on orchestration; plugins handle functionality.

---

### Q. How is polymorphism used in common design patterns (e.g., Strategy, Factory, Adapter)?
**1. Strategy Pattern**  
The Strategy pattern defines a family of interchangeable algorithms and allows them to be swapped at runtime. Polymorphism enables this by allowing different strategy implementations to conform to a common interface.
- A common interface or abstract class defines the contract for the strategy.
- Concrete strategy classes implement this interface, providing different behaviors.
- The client code interacts with the interface, unaware of the specific implementation, leveraging polymorphism to call the appropriate method.
```csharp
// Interface for the strategy
public interface IPaymentStrategy {
    void ProcessPayment(decimal amount);
}

// Concrete strategies
public class CreditCardPayment : IPaymentStrategy{
    public void ProcessPayment(decimal amount) => Console.WriteLine($"Processing credit card payment of {amount:C}");
}

public class PayPalPayment : IPaymentStrategy {
    public void ProcessPayment(decimal amount) => Console.WriteLine($"Processing PayPal payment of {amount:C}");
}

// Context class
public class PaymentContext {
    private IPaymentStrategy _strategy;
    public PaymentContext(IPaymentStrategy strategy) => _strategy = strategy;
    public void SetStrategy(IPaymentStrategy strategy) => _strategy = strategy;
    public void Process(decimal amount) => _strategy.ProcessPayment(amount);
}

// Usage
var context = new PaymentContext(new CreditCardPayment());
context.Process(100); // Output: Processing credit card payment of $100.00
context.SetStrategy(new PayPalPayment());
context.Process(100); // Output: Processing PayPal payment of $100.00
```
**Polymorphism in Action**: The `IPaymentStrategy` interface allows the `PaymentContext` to work with any payment method (e.g., `CreditCardPayment`, `PayPalPayment`) without knowing the specific implementation, enabling runtime behavior switching.  


**2. Factory Pattern**  
The Factory pattern creates objects without specifying the exact class of the object that will be created. Polymorphism allows the factory to return different concrete types that share a common base class or interface.
- A common interface or base class defines the contract for the objects created by the factory.
- The factory method returns an instance of a concrete class that implements the interface or inherits from the base class.
- Client code interacts with the returned object through the interface/base class, leveraging polymorphism.
```csharp
// Product interface
public interface IShape {
    void Draw();
}

// Concrete products
public class Circle : IShape {
    public void Draw() => Console.WriteLine("Drawing a Circle");
}
public class Square : IShape {
    public void Draw() => Console.WriteLine("Drawing a Square");
}

// Factory class
public static class ShapeFactory {
    public static IShape CreateShape(string shapeType) {
        return shapeType.ToLower() switch {
            "circle" => new Circle(),
            "square" => new Square(),
            _ => throw new ArgumentException("Invalid shape type")
        };
    }
}

// Usage
IShape shape1 = ShapeFactory.CreateShape("circle");
shape1.Draw(); // Output: Drawing a Circle
IShape shape2 = ShapeFactory.CreateShape("square");
shape2.Draw(); // Output: Drawing a Square
```
**Polymorphism in Action**: The `ShapeFactory` returns different types (`Circle` or `Square`) that implement the `IShape` interface. The client code uses the `IShape` interface to call `Draw()`, without needing to know the specific class.

**3. Adapter Pattern**
The Adapter pattern allows incompatible interfaces to work together by wrapping one interface in a compatible one. Polymorphism enables the adapter to present a unified interface to the client while delegating to the adaptee.
- A target interface defines the contract expected by the client.
- The adapter implements this interface and wraps an incompatible class (adaptee), translating calls to the adapteeâ€™s methods.
- The client interacts with the adapter through the target interface, using polymorphism to treat the adapter as the expected type.
```csharp
// Target interface
public interface IMediaPlayer {
    void Play(string file);
}

// Adaptee (incompatible interface)
public class LegacyMediaPlayer {
    public void PlayMedia(FileStream stream) => Console.WriteLine($"Playing legacy media: {stream.Name}");
}

// Adapter
public class MediaAdapter : IMediaPlayer {
    private readonly LegacyMediaPlayer _legacyPlayer;
    public MediaAdapter(LegacyMediaPlayer legacyPlayer) => _legacyPlayer = legacyPlayer;
    public void Play(string file) => _legacyPlayer.PlayMedia(File.OpenRead(file)); // Delegate to adaptee
}

// Client
IMediaPlayer player = new MediaAdapter(new LegacyMediaPlayer());
player.Play("song.mp3"); // Output: Playing legacy media: song.mp3
```
**Polymorphism in Action**: The `MediaAdapter` implements the `IMediaPlayer` interface, allowing the client to call `Play` on the adapter as if it were any other `IMediaPlayer`. The adapter translates this call to the `LegacyMediaPlayer`â€™s `PlayMedia` method.

---

### Q. What are the **performance costs** of runtime polymorphism in C#?
Runtime polymorphism in C# introduces several performance costs compared to static dispatch, Benchmarks typically show virtual calls are 2-5x slower than direct calls for simple methods. Here are the main overhead factors:  

**Virtual Method Call Overhead**  
The primary cost comes from **virtual method dispatch**. Instead of a direct function call, the runtime must:
1. Dereference the object pointer to access the object's type information
2. Look up the virtual method table (vtable) for that type
3. Index into the vtable to find the correct method implementation
4. Make an indirect call through the function pointer  

This typically adds 1-3 extra memory accesses and prevents certain compiler optimizations.

**Inlining Limitations**  
Virtual calls significantly **reduce inlining opportunities**. The compiler can't inline virtual methods at compile time since it doesn't know which implementation will be called. This is particularly costly for small, frequently-called methods that would otherwise be prime candidates for inlining.

**Cache Impact**  
Virtual dispatch can negatively affect CPU cache performance:
- **Instruction cache misses** when jumping to different method implementations
- **Data cache misses** from accessing vtables and type metadata
- **Branch prediction failures** when the same call site invokes different implementations

**Interface Dispatch Costs**  
Interface method calls are typically more expensive than virtual method calls because they require additional type checking and method resolution. The runtime must verify the object implements the interface and locate the correct method.

---

### Q. How does polymorphism interact with **reflection** and the `dynamic` type?
**1. Polymorphism + Reflection**  
Reflection in .NET lets you **inspect and interact with types and their members at runtime**.  
Polymorphism interacts with reflection in a couple of key ways:

- **Method lookup through inheritance:**  
    If you call `GetMethod` on a `Type` object, reflection respects inheritance
    ```csharp
    class Base { public virtual void Print() => Console.WriteLine("Base"); }
    class Derived : Base { public override void Print() => Console.WriteLine("Derived"); }

    var obj = new Derived();
    var method = obj.GetType().GetMethod("Print");
    method.Invoke(obj, null); // Prints "Derived"
    ```
    Reflection calls **the most derived override**, honoring runtime polymorphism.

- **Virtual / abstract members:**  
    Reflection can tell you if a method is `virtual`, `abstract`, or `override` using properties like `MethodInfo.IsVirtual`.

- **Hiding (`new`) vs overriding:**  
    If a method is hidden (not overridden), reflection can still show both versions, depending on which `Type` you inspect.
    ```csharp
    class Base { public void Print() => Console.WriteLine("Base"); }
    class Derived : Base { public new void Print() => Console.WriteLine("Derived"); }

    var baseMethod = typeof(Base).GetMethod("Print");
    var derivedMethod = typeof(Derived).GetMethod("Print");
    ```


**2. Polymorphism + `dynamic`**  
The `dynamic` type defers **binding of method calls and member access to runtime**, similar to reflection but with different ergonomics.

- **Dynamic dispatch + polymorphism:**  
    ```csharp
    class Base { public void Print() => Console.WriteLine("Base"); }
    class Derived : Base { public new void Print() => Console.WriteLine("Derived"); }

    dynamic obj = new Derived();
    obj.Print(); // Prints "Derived" - resolved at runtime
    ```
    Dynamic dispatch + polymorphism works seamlessly â€” the runtime binder respects virtual overrides.

- **Resolution mechanism:**  
    First, the runtime binder checks normal polymorphic rules (virtual methods, overrides).  
    If not found, it attempts dynamic interfaces like `IDynamicMetaObjectProvider` (used in `ExpandoObject`, `DynamicObject`).  


**3. Reflection vs `dynamic`**  
- **Reflection**: You explicitly query metadata and invoke members by name (`MethodInfo.Invoke`).
- **Dynamic**: You write natural code e.g. `d.Method()`, and the runtime binder does the reflection-like lookup for you.
```csharp
var obj = new Derived();
obj.GetType().GetMethod("Print").Invoke(obj, null); // Reflection

dynamic d = new Derived();
d.Print(); // Dynamic dispatch
```
Both respect polymorphism, but reflection is more explicit while `dynamic` is syntactic sugar for "late binding".

---

### Q. In what cases would you avoid using polymorphism, even though itâ€™s available?

**Performance-Critical Code**  
Polymorphism introduces virtual function call overhead and can prevent compiler optimizations like inlining. In tight loops, real-time systems, or embedded applications where every microsecond matters, direct function calls or templates might be preferable.  

**Simple, Static Relationships**  
When you have a small, well-defined set of types that won't change, and the logic is straightforward, polymorphism can add unnecessary complexity. A simple switch statement or conditional logic might be clearer and more maintainable.  

**When Type Information is Needed**  
If your code frequently needs to know the exact concrete type (using dynamic_cast, instanceof, or type checking), polymorphism isn't providing much benefit. You're essentially fighting against the abstraction it provides.  

**When Type Information is Needed**  
If your code frequently needs to know the exact concrete type (using dynamic_cast, instanceof, or type checking), polymorphism isn't providing much benefit. You're essentially fighting against the abstraction it provides.  

**Memory-Constrained Environments**  
Virtual function tables and the additional indirection can consume extra memory. In embedded systems or applications with strict memory budgets, this overhead might be unacceptable.  

---