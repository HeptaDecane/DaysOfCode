# Polymorphism
Polymorphism is a core concept in object-oriented programming that allows objects of different types to be treated as objects of a common super type, enabling the same method or operation to behave differently based on the object calling it. Polymorphism in C# is primarily achieved through **method overriding** (runtime polymorphism) and **method overloading** (compile-time polymorphism).

## ðŸ”‘ Types of Polymorphism in C#

1. **Compile-time Polymorphism (Static Binding / Early Binding)**
   - Achieved using **method overloading** and **operator overloading**.
   - Which method to call is decided at **compile time**.
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b;
        public int Add(int a, int b, int c) => a + b + c;
    }

    class Program {
        static void Main() {
            Calculator calc = new Calculator();
            Console.WriteLine(calc.Add(2, 3));         // Calls int version
            Console.WriteLine(calc.Add(2.5, 3.5));     // Calls double version
            Console.WriteLine(calc.Add(1, 2, 3));      // Calls 3-parameter version
        }
    }
    ```
2. **Runtime Polymorphism (Dynamic Binding / Late Binding)**
    - Achieved using **method overriding** (with inheritance and `virtual`/`override` keywords).
    - Which method to call is decided at **runtime**, depending on the object type.
    ```csharp
    class Animal {
        public virtual void Speak() {
            Console.WriteLine("The animal makes a sound.");
        }
    }

    class Dog : Animal {
        public override void Speak() {
            Console.WriteLine("The dog barks.");
        }
    }

    class Cat : Animal {
        public override void Speak() {
            Console.WriteLine("The cat meows.");
        }
    }

    class Program {
        static void Main() {
            Animal a1 = new Dog();
            Animal a2 = new Cat();

            a1.Speak(); // Output: The dog barks.
            a2.Speak(); // Output: The cat meows.
        }
    }
    ```

## ðŸŽ¯ Goals of Polymorphism
- **Code Reusability**: 
    - Write general code once, and let derived classes provide their specific behavior.
    - Example: A `List<T>` works with `int`, `string`, `Car`, or any object type, because of polymorphism.

- **Extensibility / Flexibility**:
    - New classes can be added without changing existing code, as long as they implement the same interface or override the base methods.
    - Example: Adding a new `Bird` class with `Speak()` doesnâ€™t require changing the existing `Animal` code.

- **Loose Coupling**:
    - Code depends on **abstractions (interfaces or base classes)** instead of concrete implementations.
    - Makes systems less fragile and easier to modify.

- **Improved Readability**:
    - You can call the same method on different objects, and the behavior is appropriate without extra conditionals (`if` / `switch`).
    - Example: Instead of checking `if (animal is Dog)` everywhere, just call `animal.Speak()` and let polymorphism handle it.

- **Supports "Program to an Interface" Principle**:
    - Allows you to use dependency injection and design patterns effectively (like Strategy, Factory, Adapter).

In short, the goal of polymorphism is to **treat different objects uniformly while letting each object define its own specific behavior**.


## âœ… Ways C# supports polymorphism:

### 1. Compile-time Polymorphism
Achieved at compile time.
- **Method Overloading**: Same method name but different parameter signatures.
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b; // overload
    }
    ```

- **Operator Overloading**: Redefine operators for user-defined types.
    ```csharp
    class Complex {
        public int Real { get; set; }
        public int Imaginary { get; set; }

        public static Complex operator +(Complex c1, Complex c2) 
            => new Complex { Real = c1.Real + c2.Real, Imaginary = c1.Imaginary + c2.Imaginary };
    }
    ```

### 2. Runtime Polymorphism
Achieved at runtime, mainly with **inheritance** and **interfaces**.
- **Method Overriding with `virtual` and `override`**
    ```csharp
    class Animal {
        public virtual void Speak() => Console.WriteLine("Animal speaks");
    }

    class Dog : Animal {
        public override void Speak() => Console.WriteLine("Dog barks");
    }
    ```

- **Abstract Classes and Methods**: Force derived classes to provide implementation.
    ```csharp
    abstract class Shape {
        public abstract void Draw();
    }

    class Circle : Shape {
        public override void Draw() => Console.WriteLine("Drawing Circle");
    }
    ```

- **Interfaces**: Multiple classes implement the same contract. 
    ```csharp
    interface IPayment {
        void Pay(decimal amount);
    }

    class CreditCardPayment : IPayment {
        public void Pay(decimal amount) => Console.WriteLine($"Paid {amount} using Credit Card");
    }
    ```

- **Method Hiding**: Using the `new` keyword. Not true overriding, but allows redefining a method in a derived class.
    ```csharp
    class Base {
        public void Show() => Console.WriteLine("Base Show");
    }

    class Derived : Base {
        public new void Show() => Console.WriteLine("Derived Show");
    }
    ```

### 3. Other Forms of Polymorphism in C#
- **Generics (Parametric Polymorphism)**: Write code that works with any data type.
    ```csharp
    class GenericList<T> {
        private List<T> _items = new List<T>();

        public void Add(T item) => _items.Add(item);
        public T Get(int index) => _items[index];
    }
    ```

- **Delegates and Events**: Allow methods to be passed as parameters, enabling callback mechanisms.
    ```csharp
    public delegate void Notify(string message);

    class Process {
        public Notify OnProcessCompleted;

        public void StartProcess() {
            // Process logic here
            OnProcessCompleted?.Invoke("Process Completed!");
        }
    }
    ```

- **Dynamic Keyword (Dynamic Binding)**: Method resolution happens at runtime, bypassing compile-time checks.
    ```csharp
    dynamic obj = "Hello, World!";
    Console.WriteLine(obj.Length); // Resolved at runtime
    ```

## Interview Questions

### Q. What is polymorphism in C#, and why is it important?
Polymorphism in C# is a fundamental object-oriented programming concept that allows objects of different types to be treated as instances of the same base type, while maintaining their specific behaviors.  

There are several types of polymorphism in C#:    
- **Runtime Polymorphism (Method Overriding)**: This is achieved through inheritance and virtual methods. A base class defines a virtual method, and derived classes can override it with their own implementations.
- **Interface Polymorphism**: Different classes can implement the same interface, allowing them to be used interchangeably.
- **Compile-time Polymorphism (Method Overloading)**: This is achieved by defining multiple methods with the same name but different parameter lists within the same class.  


**Why Polymorphism is Important**  
Polymorphism is essential for writing flexible, maintainable, and scalable object-oriented code. It enables you to design systems that can grow and adapt to new requirements with minimal changes to existing code.  
- **Flexibility and Extensibility**: You can write code that works with **base types or interfaces**, making it easy to add new derived types without changing existing code. This follows the Open/Closed Principle - open for extension, closed for modification.  
- **Code Reusability**: Instead of writing separate methods for each specific type, you can write generic code that works with multiple types.  
- **Maintainability**: Changes to specific implementations don't affect the code that uses them polymorphically. This reduces coupling between components and makes systems easier to maintain.  
- **Abstraction**: Polymorphism allows you to work with objects at a higher level of abstraction, focusing on what they can do rather than their specific implementation details. This makes code more readable and conceptually cleaner.  
- **Design Patterns**: Many important design patterns rely heavily on polymorphism, such as Strategy, Factory, and Template Method patterns. These patterns help solve common programming problems elegantly.  

---

### Q. What are the two types of polymorphism in C#?
**1. Compile-time Polymorphism (Static Polymorphism)**  
This is resolved at compile time and includes:  
- **Method Overloading**: Multiple methods with the same name but different parameters (different number, types, or order of parameters)
- **Operator Overloading**: Defining custom behavior for operators like +, -, ==, etc. for user-defined types

**2. Runtime Polymorphism (Dynamic Polymorphism)**
This is resolved at runtime and is achieved through:  
- **Method Overriding**: Using virtual methods in base classes and override methods in derived classes
- **Interface Implementation**: Implementing interface methods in different classes  

Runtime polymorphism allows you to call the same method on different objects and get different behaviors based on the actual object type at runtime, which is determined through method dispatch using the virtual method table (vtable).

---

### Q. What is the difference between method overloading and method overriding?
**Method Overloading:**  
- **Definition**: Method overloading allows a class to have multiple methods with the **same name** but different **parameter lists** (different number, types, or order of parameters).
- **Purpose**: It provides flexibility to call the same method name with different inputs, improving code readability and reusability.
- **Key Characteristics**:
  - Occurs within the **same class**.
  - Methods must differ in their **signature** (number, type, or order of parameters).
  - The **return type** alone cannot differentiate overloaded methods.
  - It is resolved at **compile time** (static polymorphism).
  - Example:
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b; // Overloaded method
        public int Add(int a, int b, int c) => a + b + c; // Overloaded method
    }
    ```

**Method Overriding:**
- **Definition**: Method overriding allows a **derived class** to provide a specific implementation of a method that is already defined in its **base class**.
- **Purpose**: It enables runtime polymorphism, allowing a derived class to modify or extend the behavior of a base class method.
- **Key Characteristics:**
	- Occurs between a **base class** and a **derived class**.
	- The method in the derived class must have the **same name, parameters, and return type** as the method in the base class.
	- The base class method must be marked with the `virtual` or `abstract` keyword, and the derived class method must use the `override` keyword.
	- It is resolved at **runtime** (dynamic polymorphism).
	- Example:
		```csharp
		class Shape {
			public virtual void Draw() => Console.WriteLine("Drawing a shape");
		}

		class Circle : Shape {
			public override void Draw() => Console.WriteLine("Drawing a circle");
		}
		```

**Key Differences:**  
Aspect | Method Overloading | Method Overriding
--- | --- | ---
Definition | Same method name, different parameter lists. | Same method name, same parameters, different implementation.
Location | Within the same class. | Between base and derived classes.
Polymorphism Type | Compile-time (static). | Runtime (dynamic).
Method Signature | Must differ (parameters). | Must be identical (name, parameters, return type).
Keywords | No special keywords required. | `virtual`/`abstract` in base class, `override` in derived class.
Purpose | Flexibility in method calls with different inputs. | Customize or extend base class behavior.

---

### Q. What is the purpose of the `virtual` and `override` keywords in C#?
**`virtual` Keyword:**  
The `virtual` keyword is used in a base class to indicate that a method can be overridden by derived classes. It allows you to provide a default implementation while giving subclasses the option to provide their own specific implementation.
```csharp
public class Shape {
	public virtual void Draw() {
		Console.WriteLine("Drawing a shape");
	}
}
```

**`override` Keyword:**  
The `override` keyword is used in a derived class to provide a new implementation of a virtual method from the base class. The method signature must exactly match the base class method.
```csharp
public class Circle : Shape {
	public override void Draw() {
		Console.WriteLine("Drawing a circle");
	}
}

public class Square : Shape {
	public override void Draw() {
		Console.WriteLine("Drawing a square");
	}
}
```

**Key Points:**  
- **Polymorphism**: When you have a base class reference pointing to a derived class object, calling a virtual method will execute the overridden version in the derived class, not the base class version.
	```csharp
	Shape circle = new Circle();
	circle.Draw(); // Output: Drawing a circle
	```

- **Method Chaining**: You can call the base class implementation from an overridden method using base.MethodName():
	```csharp
	public class Circle : Shape {
		public override void Draw() {
			base.Draw();	// Call base implementation
			Console.WriteLine("Drawing a circle");
		}
	}
	```
---

### Q. Can you overload methods in C# only by changing the return type? Why or why not?
No, you cannot overload methods in C# by changing only the return type. Method overloading in C# is determined by the method's **signature**, which includes:
1. Method name
2. Number of parameters
3. Type of parameters
4. Order of parameters
The return type is **not** part of the method signature for overloading purposes.

**The Problem with Return-Type-Only Overloading**  
Consider this hypothetical scenario if C# allowed return-type-only overloading:
```csharp
public int Calculate(int x, int y) { return x + y; }
public string Calculate(int x, int y) { return (x + y).ToString(); }
```
Now imagine calling this method:
```csharp
var result = Calculate(5, 10); // Which method should be called?
```
The compiler cannot determine which overload to use because the call site doesn't specify what type the result should be.  
This creates ambiguity that would make the code unpredictable and error-prone.  

**What Actually Works for Overloading**  
```csharp
public int Calculate(int x, int y) { return x + y; }
public int Calculate(double x, double y) { return (int)(x + y); }
public int Calculate(int x, int y, int z) { return x + y + z; }
public int Calculate(string operation, int x, int y)  { 
    return operation == "add" ? x + y : x - y; 
}
```

**Alternative Approaches**  
If you need different return types for similar operations, consider:  
- **Different method names**: `CalculateSum()` and `CalculateDescription()`
- **Generic methods**: Use type parameters to handle different return types
- **Out parameters**: Return multiple values or use tuple returns

---

### Q. What is operator overloading? Give an example.
Operator overloading is a feature that allows you to define custom behavior for operators (like +, -, *, ==, etc.) when they are used with user-defined types such as classes or structs. Instead of operators only working with built-in types like int or string, you can make them work meaningfully with your custom objects.

In C#, you implement operator overloading by defining special static methods in your class using the `operator` keyword.  
Here's a practical example with a `Vector2D` class:
```csharp
public class Vector2D {
    public double X { get; set; }
    public double Y { get; set; }
    
    public Vector2D(double x, double y) {
        X = x;
        Y = y;
    }
    
    // Overload the + operator for vector addition
    public static Vector2D operator +(Vector2D v1, Vector2D v2) {
        return new Vector2D(v1.X + v2.X, v1.Y + v2.Y);
    }
    
    // Overload the - operator for vector subtraction
    public static Vector2D operator -(Vector2D v1, Vector2D v2) {
        return new Vector2D(v1.X - v2.X, v1.Y - v2.Y);
    }
    
    // Overload the * operator for scalar multiplication
    public static Vector2D operator *(Vector2D v, double scalar) {
        return new Vector2D(v.X * scalar, v.Y * scalar);
    }
    
    // Overload the * operator for scalar multiplication (commutative)
    public static Vector2D operator *(double scalar, Vector2D v) {
        return new Vector2D(v.X * scalar, v.Y * scalar);
    }
    
    // Overload the == operator for equality comparison
    public static bool operator ==(Vector2D v1, Vector2D v2) {
        if (ReferenceEquals(v1, v2)) return true;
        if (v1 is null || v2 is null) return false;
        return Math.Abs(v1.X - v2.X) < 0.0001 && Math.Abs(v1.Y - v2.Y) < 0.0001;
    }
    
    // Overload the != operator (required when overloading ==)
    public static bool operator !=(Vector2D v1, Vector2D v2) {
        return !(v1 == v2);
    }
    
    // Override Equals and GetHashCode (recommended when overloading == and !=)
    public override bool Equals(object obj) {
        if (obj is Vector2D other)
            return this == other;
        return false;
    }
    
    public override int GetHashCode() {
        return HashCode.Combine(X, Y);
    }
    
    // Override ToString for better display
    public override string ToString() {
        return $"({X}, {Y})";
    }
}
```

**Syntax**: Operator overloads must be `public static` methods with the operator keyword, followed by the `operator` symbol.  

**Common operators you can overload:**  
- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Comparison: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Unary: `+`, `-`, `!`, `~`, `++`, `--`
- Others: `true`, `false`, implicit/explicit conversions
  
**Important rules:**
- Some operators come in pairs (like `==` and `!=`) - if you overload one, you should overload both
- When overloading `==` and `!=`, you should also override `Equals()` and `GetHashCode()`
- Operators like `&&`, `||`, and assignment operators (`+=`, `-=`) cannot be directly overloaded, but they use the overloaded versions of their component operators

**Benefits:**
- Makes code more intuitive and readable
- Allows your custom types to behave like built-in types
- Enables natural mathematical operations on custom objects

---

### Q. What is the difference between **compile-time polymorphism** and **runtime polymorphism**?
The key difference between compile-time and runtime polymorphism lies in **when** the decision about which method to call is made:
- **Compile-time polymorphism** (or static polymorphism) is resolved during compilation. This is typically achieved through method overloading or operator overloading.
- **Runtime polymorphism** (or dynamic polymorphism) is resolved during runtime. This is usually achieved through method overriding, where a base class reference points to a derived class object.  

Aspect | Compile-Time | Runtime
--- | --- | ---
When decided | During compilation | During execution
Performance | Faster (no runtime lookup) | Slightly slower (virtual method table lookup)
Flexibility | Less flexible | More flexible
Method resolution | Based on compile-time type | Based on actual object type
Keywords | Method overloading, operator overloading | `virtual`, `override`, `abstract`, interfaces

Runtime polymorphism is more powerful for creating flexible, extensible code where you don't know the exact types until runtime, while compile-time polymorphism offers better performance when the types are known at compile time.

---

### Q. Can you override static methods in C#? Why or why not?
No, you cannot override static methods in C#. Here's why:  

Static methods belong to the class itself, not to instances of the class. They are resolved at compile-time based on the type, not at runtime based on the object's actual type. Method overriding relies on runtime polymorphism, which requires instance methods and a virtual table (vtable) to resolve the method call dynamically. Since static methods are not associated with instances, they don't participate in this mechanism.  

However, you can **hide** a static method in a derived class using the `new` keyword. This is not overriding but shadowing, meaning the derived class provides a new implementation that hides the base class's static method. The method called depends on the compile-time type of the reference, not the runtime type.  

```csharp
public class Base {
    public static void Method() { }
}

public class Derived : Base {
    // This won't compile with 'override'
    // public override static void Method() { } // Error!
    
    // This creates a completely separate method (method hiding)
    public static void Method() { } // Legal but not overriding
}
```
---

### Q. Whatâ€™s the difference between **method overriding** and **method hiding** (`new` keyword)?  

**Method Overriding**
- **Definition**: Method overriding occurs when a derived class provides a specific implementation for a **virtual** or **abstract** method defined in a base class. The overridden method in the derived class replaces the base class method when called on an instance of the derived class, even if the instance is referenced as the base class type.
- **Keywords**: Requires the base class method to be marked with `virtual` or `abstract`, and the derived class method to be marked with `override`.
- **Polymorphism**: Enables **runtime polymorphism**, where the method to be executed is determined at runtime based on the actual type of the object.
- **Behavior**: When a method is overridden, calling the method on a base class reference that points to a derived class object invokes the derived class's implementation.
- **Example**:
    ```csharp
    public class Base {
        public virtual void Show() {
            Console.WriteLine("Base Show");
        }
    }

    public class Derived : Base {
        public override void Show() {
            Console.WriteLine("Derived Show");
        }
    }

    Base obj = new Derived();
    obj.Show(); // Output: "Derived Show"
    ```

**Method Hiding**
- **Definition**: Method hiding occurs when a derived class defines a method with the same name as a method in the base class, but it does **not** override the base class method. Instead, it hides the base class method, creating a new method that is unrelated to the base class method in terms of polymorphism.
- **Keyword**: Uses the `new` keyword explicitly to indicate that the method in the derived class is intentionally hiding the base class method. If `new` is omitted, the compiler may issue a warning but still hide the method.
- **Polymorphism**: Does **not** enable runtime polymorphism. The method called depends on the reference type, not the actual object type.
- **Behavior**: When a method is hidden, calling the method on a base class reference invokes the base class method, while calling it on a derived class reference invokes the derived class method.
- **Example**:
    ```csharp
        public class Base {
            public void Show() {
                Console.WriteLine("Base Show");
            }
        }

        public class Derived : Base {
            public new void Show() { // Hides the base class method
                Console.WriteLine("Derived Show");
            }
        }

        Base obj1 = new Derived();
        obj1.Show(); // Output: "Base Show" (base class method)

        Derived obj2 = new Derived();
        obj2.Show(); // Output: "Derived Show" (derived class method)
    ```

**When to Use**  
**Method Overriding**: Use when you want polymorphic behavior, where the derived class provides a specialized implementation of a method that the base class defines as part of its contract. Common in scenarios where you want subclasses to customize behavior (e.g., a `Shape` class with a `Draw` method overridden by `Circle` or `Square`).  
**Method Hiding**: Use when you want to define a method in the derived class that happens to have the same name as a base class method but is not intended to participate in the same polymorphic behavior. This is less common and should be used cautiously to avoid confusion.

---

### Q. What happens if you have two methods with the same signature in base and derived classes, but donâ€™t use `virtual`, `override`, or `new`?  
When you have two methods with the same signature in base and derived classes without using `virtual`, `override`, or `new` keywords, you get **method hiding** (also called method shadowing).
```csharp
class Base {
    public void DoSomething() {
        Console.WriteLine("Base implementation");
    }
}

class Derived : Base {
    public void DoSomething() { // This hides the base method
        Console.WriteLine("Derived implementation");
    }
}

Base baseRef = new Derived();
baseRef.DoSomething(); // Output: "Base implementation"

Derived derivedRef = new Derived();
derivedRef.DoSomething(); // Output: "Derived implementation"
```

**Behavior:**  
- **Compile-time warning**: The compiler will generate a warning like "Member hides inherited member. Use the new keyword if hiding was intended."
- **No polymorphism**: Unlike virtual methods, there's no dynamic dispatch. The method called is determined by the compile-time type of the reference, not the runtime type of the object.

---

### Q. Can constructors be overridden in C#? Why?  
No, constructors cannot be overridden in C#. Here's why:  
- **Constructors are not inherited**: Unlike regular methods, constructors are not inherited by derived classes, and without inheritance, there's nothing to override. Each class is responsible for its own initialization, and derived classes must call the base class constructor explicitly if needed.
- **Purpose of constructors**: Constructors are specifically responsible for initializing the particular class they belong to, and each class needs its own initialization logic. Virtual methods are designed for polymorphic behavior where derived classes can change the implementation.
- **No virtual/override keywords allowed**: The compiler doesn't allow you to mark constructors as `virtual`, `override`, or `abstract`. This is by design to prevent the confusion that would arise from constructor polymorphism.  

**What You Can Do Instead:**  
- Use constructor chaining with the `base` keyword to call a base class constructor.
    ```csharp
    public class BaseClass {
        public BaseClass(int value) {
            // Base initialization
        }
    }

    public class DerivedClass : BaseClass  {
        public DerivedClass(int value) : base(value) {  // Call base constructor
            // Additional derived class initialization
        }
    }
    ```
- Use factory methods or static methods to create instances of classes.
- Implement the **Builder** pattern to construct complex objects step by step.
- Use composition over inheritance to achieve code reuse without relying on constructor overriding.
  
---

### Q. How does polymorphism improve code **reusability** and **maintainability**?  
**Code Reusability**  
- **Shared Interfaces or Superclasses:**  
    Polymorphism allows methods to operate on objects of a common interface or superclass, so you can write code that works with multiple types without duplicating logic.  
    **Example**: A method that processes a `Shape` interface can handle `Circle`, `Rectangle`, or any new shape class implementing `Shape`, without rewriting the method. 

- **Generic Code:**  
    By using polymorphic types (e.g., abstract classes or interfaces), you can write generic algorithms or functions that apply to a family of related classes.  
    **Example**: A `List` interface allows the same code to work with `ArrayList`, `LinkedList`, or custom list implementations.

- **Extensibility:**  
    New classes can be added that conform to the same interface or inherit from the same superclass, and existing code can use them without modification.  
    **Example**: Adding a new `PaymentMethod` (e.g., `CryptoPayment`) to a system that processes `CreditCard` and `PayPal` payments requires only implementing the `PaymentMethod` interface.  

**Code Maintainability**  
- **Centralized Logic:**  
    Polymorphism reduces code duplication by centralizing shared behavior in superclasses or interfaces, making it easier to update logic in one place.  
    **Example**: Changing how a `draw()` method works for all shapes can be done in the `Shape` superclass or interface, rather than in each shape class.  

- **Reduced Coupling:**  
    Code depends on abstractions (interfaces or superclasses) rather than concrete implementations, making it easier to swap or modify implementations without affecting the rest of the system.  
    **Example**: A `DatabaseConnection` interface allows switching between `MySQLConnection` and `PostgreSQLConnection` without changing the code that uses the connection.  

- **Easier Debugging and Testing:**  
    Polymorphic code is often more modular, as it relies on well-defined interfaces or inheritance hierarchies. This modularity simplifies debugging and testing, as you can focus on individual implementations or mock polymorphic types.  
    **Example**: Unit tests can mock a `Logger` interface to test logging behavior without touching the actual file or console logger.  

**Conclusion**  
Polymorphism enhances **reusability** by enabling generic, reusable code that works with multiple types and supports extensibility. It improves **maintainability** by reducing duplication, decoupling components, and simplifying updates or debugging. By designing systems around abstractions, polymorphism makes code more flexible and easier to manage as requirements evolve.

---

### Q. When would you use **abstract classes** vs **interfaces** to achieve polymorphism?  
**Use abstract classes when:**  
- **Shared Implementation**: You want to provide common functionality (code, fields, or properties) that derived classes can inherit and reuse, while still enforcing certain methods to be overridden.  
   **Example**: A base class `Shape` with a common method `CalculateArea()` and an abstract method `Draw()`.  
- **Related Classes**: The classes share an "is-a" relationship (e.g., `Triangle` is a `Shape`) and form a natural hierarchy.
- **State Management**: The base class needs to maintain state (fields or properties) shared by derived classes.
- **Versioning Control**: You need control over the class hierarchy, as abstract classes are less flexible for external extensions (e.g., you can add non-abstract methods without breaking derived classes).

**Use abstract classes when:**  
- **Contract-Based Design**: You want to define a contract that unrelated classes can implement, focusing on "can-do" relationships (e.g., `IFlyable` for anything that can fly, like a `Bird` or `Airplane`).
- **Multiple Implementations**: A class needs to implement multiple behaviors, as C# allows multiple interface implementations.
- **Loose Coupling**: You want flexibility and decoupling, allowing classes to implement the interface without being tied to a specific hierarchy.
- **Cross-Domain Abstraction**: You need to enforce behavior across unrelated types (e.g., `IComparable` for sorting different objects).

**Practical Example**  
Suppose you're building a system for different payment methods:  

- Use an **abstract class** `Payment` if all payment methods share common logic, like `ProcessTransaction()`, and have shared state, like `Amount`.
    ```csharp
    abstract class Payment {
        protected decimal Amount { get; set; }
        public void ProcessTransaction() => Console.WriteLine("Processing...");
        public abstract void Validate();
    }

    class CreditCardPayment : Payment {
        public override void Validate() => Console.WriteLine("Validating card.");
    }
    ```

- Use an interface `IPaymentMethod` if you only need to enforce that all payment methods can `Pay()`, regardless of their implementation.
    ```csharp
    interface IPaymentMethod {
        void Pay();
    }

    class PayPal : IPaymentMethod {
        public void Pay() => Console.WriteLine("Paying via PayPal.");
    }

    class Crypto : IPaymentMethod {
        public void Pay() => Console.WriteLine("Paying via Crypto.");
    }
    ```
---

### Q. How does polymorphism support the **Open/Closed Principle (OCP)** in SOLID design?

Polymorphism is one of the key mechanisms that enables the Open/Closed Principle, which states that software entities should be open for extension but closed for modification. Here's how they work together:  
**Closed for Modification**: The existing code that uses polymorphic interfaces doesn't need to change when new implementations are added. The client code works with abstract types (interfaces or base classes) rather than concrete implementations.  
**Open for Extension**: New functionality can be added by creating new classes that implement existing interfaces or inherit from base classes, without touching the original code.  

**Practical Example**  
Consider a payment processing system:  
```csharp
// Original interface - remains unchanged
interface PaymentProcessor {
    void processPayment(double amount);
}

// Original implementation
class CreditCardProcessor : PaymentProcessor {
    public void processPayment(double amount) {
        // Credit card logic
    }
}

// Client code - closed for modification
class OrderService {
    private PaymentProcessor processor;
    
    public OrderService(PaymentProcessor processor) {
        this.processor = processor;
    }
    
    public void completeOrder(double amount) {
        processor.processPayment(amount); // Polymorphic call
    }
}
```

Now, when you need to add PayPal support:
```csharp
// Extension - new implementation
class PayPalProcessor : PaymentProcessor {
    public void processPayment(double amount) {
        // PayPal-specific logic
    }
}
```
The `OrderService` class never needs modification - it can work with any `PaymentProcessor` implementation through polymorphism.  

**Without polymorphism**: adding new payment methods would require modifying the client code with conditional logic:
```csharp
// Violates OCP - requires modification for each new type
if (paymentType.Equals("creditcard")) {
    // credit card logic
} else if (paymentType.Equals("paypal")) {
    // paypal logic
} // More modifications needed for each new type
```
---
