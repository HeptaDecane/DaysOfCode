# Polymorphism
Polymorphism is a core concept in object-oriented programming that allows objects of different types to be treated as objects of a common super type, enabling the same method or operation to behave differently based on the object calling it. Polymorphism in C# is primarily achieved through **method overriding** (runtime polymorphism) and **method overloading** (compile-time polymorphism).

## ðŸ”‘ Types of Polymorphism in C#

1. **Compile-time Polymorphism (Static Binding / Early Binding)**
   - Achieved using **method overloading** and **operator overloading**.
   - Which method to call is decided at **compile time**.
    ```csharp
    class Calculator {
        public int Add(int a, int b) => a + b;
        public double Add(double a, double b) => a + b;
        public int Add(int a, int b, int c) => a + b + c;
    }

    class Program {
        static void Main() {
            Calculator calc = new Calculator();
            Console.WriteLine(calc.Add(2, 3));         // Calls int version
            Console.WriteLine(calc.Add(2.5, 3.5));     // Calls double version
            Console.WriteLine(calc.Add(1, 2, 3));      // Calls 3-parameter version
        }
    }
    ```
2. **Runtime Polymorphism (Dynamic Binding / Late Binding)**
    - Achieved using **method overriding** (with inheritance and `virtual`/`override` keywords).
    - Which method to call is decided at **runtime**, depending on the object type.
    ```csharp
    class Animal {
        public virtual void Speak() {
            Console.WriteLine("The animal makes a sound.");
        }
    }

    class Dog : Animal {
        public override void Speak() {
            Console.WriteLine("The dog barks.");
        }
    }

    class Cat : Animal {
        public override void Speak() {
            Console.WriteLine("The cat meows.");
        }
    }

    class Program {
        static void Main() {
            Animal a1 = new Dog();
            Animal a2 = new Cat();

            a1.Speak(); // Output: The dog barks.
            a2.Speak(); // Output: The cat meows.
        }
    }
    ```

## ðŸŽ¯ Goals of Polymorphism
- **Code Reusability**: 
    - Write general code once, and let derived classes provide their specific behavior.
    - Example: A `List<T>` works with `int`, `string`, `Car`, or any object type, because of polymorphism.

- **Extensibility / Flexibility**:
    - New classes can be added without changing existing code, as long as they implement the same interface or override the base methods.
    - Example: Adding a new `Bird` class with `Speak()` doesnâ€™t require changing the existing `Animal` code.

- **Loose Coupling**:
    - Code depends on **abstractions (interfaces or base classes)** instead of concrete implementations.
    - Makes systems less fragile and easier to modify.

- **Improved Readability**:
    - You can call the same method on different objects, and the behavior is appropriate without extra conditionals (`if` / `switch`).
    - Example: Instead of checking `if (animal is Dog)` everywhere, just call `animal.Speak()` and let polymorphism handle it.

- **Supports "Program to an Interface" Principle**:
    - Allows you to use dependency injection and design patterns effectively (like Strategy, Factory, Adapter).

In short, the goal of polymorphism is to **treat different objects uniformly while letting each object define its own specific behavior**.

